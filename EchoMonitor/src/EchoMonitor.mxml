<?xml version="1.0" encoding="utf-8"?>
<!--

   Copyright 2011-2016 Marko Puusaar / Information Technology Foundation for Education

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


   TODO:
    - move the user information to EncryptedLocalStore
    - handle monitoring from different timezones than the appliance with correct dates and times
    - handle locale change with more grace :)
    - [DONE] implement audio level monitoring
    - [DONE] clear audio error message when a capture ends
    - [DONE] notify the user of any network/connection problems that cause EchoMonitor not to be able to connect to the selected appliance
    - [DONE] optimize connections to the capture appliance
    - [DONE] improve the display of monitoring area (hide scrollbars)

-->
<mx:WindowedApplication
	xmlns:mx="http://www.adobe.com/2006/mxml"
	layout="absolute"
	horizontalAlign="center"
	verticalAlign="middle"
	width="900"
	height="650"
	applicationComplete="initApp(event);"
	backgroundGradientAlphas="[1.0, 1.0]"
	backgroundGradientColors="[#105761, #090D0B]"
	showStatusBar="false"
	frameRate="12">
<mx:HTTPService
	id="infoHTTPService"
	resultFormat="e4x" 
	result="infoHandler(event)"
	fault="httpFault('infoHTTPService',event)"
	requestTimeout="3" />
<mx:HTTPService
	id="controlHTTPService"
	resultFormat="e4x" 
	result="controlHandler(event)"
	fault="httpFault('controlHTTPService',event)"
	requestTimeout="3"
	method="POST" />
<mx:Zoom
	id="zoomIn"
	zoomHeightFrom="0.0"
	zoomWidthFrom="0.0"
    zoomHeightTo="1.0"
    zoomWidthTo="1.0" />
<mx:Zoom id="zoomOut" 
	zoomHeightFrom="1.0"
	zoomWidthFrom="1.0"
	zoomHeightTo="0.0"
	zoomWidthTo="0.0" />
<mx:Sequence id="doGlow" repeatCount="0">
	<mx:Glow
		duration="100"
		alphaFrom="0" alphaTo="1"
		blurXFrom="0.0" blurXTo="30.0" 
		blurYFrom="0.0" blurYTo="30.0"  strength="2"
		color="0xFF5100" />
	<mx:Glow
		duration="800"  
		alphaFrom="1" alphaTo="0"
		blurXFrom="30.0" blurXTo="0.0"
		blurYFrom="30.0" blurYTo="0.0"  strength="2"
		color="0xFF5100" />
</mx:Sequence>
<mx:GlowFilter id="okGlow"
	color="0x000000"
	alpha="1"
	blurX="20"
	blurY="20"
	quality="2" />
<mx:GlowFilter id="warningGlow"
	color="0xFF5100"
	alpha="1"
	blurX="20"
	blurY="20" />
<mx:BlurFilter id="blurredBox"
	blurX="10"
	blurY="10"
	quality="3" />
<mx:DateFormatter id="dateFormatter" 
	formatString="{resourceManager.getString('EchoMonitor', 'DATE_FORMAT')}" />
<mx:DateFormatter id="timeFormatter"
	formatString="{resourceManager.getString('EchoMonitor', 'TIME_FORMAT')}" />
<mx:DateFormatter id="timeWithSecondsFormatter"
	formatString="{resourceManager.getString('EchoMonitor', 'TIME_WITH_SECONDS_FORMAT')}" />
<mx:Metadata>
  [ResourceBundle("EchoMonitor")]
</mx:Metadata>
<mx:Script>
        <![CDATA[
        	import mx.events.FlexEvent;
            import flash.display.Loader;
		    import flash.events.TimerEvent;
		    import flash.media.Sound;
		    import flash.utils.Timer;
		    import mx.collections.*;
			import mx.controls.Alert;
			import mx.events.AIREvent;
            import mx.rpc.http.HTTPService;
            import mx.rpc.events.ResultEvent;
            import mx.rpc.events.FaultEvent;
            import mx.utils.Base64Encoder;
            import mx.utils.StringUtil;
            
            // Application variables
            private var applianceURL:String;
            private var applianceDefaultAdHocProfile:String = null;
            private var applianceDefaultMonitoringProfile:String = null;
            private var adHocProfile:String = null;
            private var KeysDown:Object = new Object();
            private var username:String, password:String;
            private var monitorTimer:Timer, infoTimer:Timer;
            private var audioError:int, videoError:int, displayError:int;
            private var audioErrorStartTime:Date;
            private var audioErrorCount:int = 0;
            private var monitorImageLoader:Array = [];
            private var monitorImageRequestHeader:URLRequestHeader;
            private var monitoringProfile:String = null;
            private var controlBarInfoErrorColor:String = "#C80101";
            private var configurationFileName:String = "configuration.xml";
            private var networkErrorCount:int = 0;
            private var captureState:String = null;
            private var eventSound:Array = [];
            // End of application variables

			// Create the configuration object
			private var configuration:Object = new Object();

			// Define some constants
            private const day:int = 1000 * 60 * 60 * 24;
            private const hour:int = 1000 * 60 * 60;
            private const minute:int = 1000 * 60;

            private const monitorImageWidth:int = 320;

            private var configurationFile:File;
            private var configurationFileStream:FileStream;
            private var configurationXML:XML;
            [Bindable] private var appliances:XMLListCollection;
            
            [Embed(source="assets/stop.png")]
			[Bindable]
			public var stopIcon:Class;
            
            [Embed(source="assets/pause.png")]
			[Bindable]
			public var pauseIcon:Class;
			
			[Embed(source="assets/next.png")]
			[Bindable]
			public var extendIcon:Class;
			
			[Embed(source="assets/play.png")]
			[Bindable]
			public var resumeIcon:Class;

            // initApp
            public function initApp(e:Event):void {
				resourceManager.addEventListener(Event.CHANGE, applyLocale);

				// Set default values for configuration
				configuration.audioErrorLevel = 5000;
				configuration.audioErrorLimit = 20;
				configuration.audioWarningLimit = 10;
				configuration.controlRequestTimeout = 3; // in seconds
				configuration.debug = false;
				configuration.defaultAdHocDescription = "Ad Hoc Capture (%t, %r)";
				configuration.defaultAdHocDuration = 900; // in seconds
				configuration.defaultAdHocProfile = null;
				configuration.defaultLocale = "en_US";
				configuration.defaultMonitoringDuration = 900; // in seconds
				configuration.defaultMonitoringProfile = null;
				configuration.enableAdHocCapture = false;
				configuration.enableCaptureControl = true;
				configuration.eventSoundCaptureBeginning = false;
				configuration.eventSoundSignalError = false;
				configuration.hideAdHocButton = false;
				configuration.hideControlButtons = false;
				configuration.hideLiveStreamInfo = false;
				configuration.hideStartMonitoringButton = true;
				configuration.hideSourceLabel = false;
				configuration.hideSettingsButton = false;
				configuration.hideVUMeter = false;
				configuration.ignoreMissingDisplaySignal = false;
				configuration.ignoreMissingVideoSignal = false;
				configuration.infoRequestTimeout = 3; // in seconds
				configuration.infoTimerActive = 3000; // in milliseconds
				configuration.infoTimerIdle = 10000; // in milliseconds
				configuration.showFirstApplianceAutomatically = false;
				configuration.showRoomSelection = true;
				configuration.startFullscreen = true;

				// Load the configuration values from configuration file
            	loadConfiguration();
            	
            	if(configuration.defaultLocale) {
            		setLocale(configuration.defaultLocale);
            	}

				if(configuration.startFullscreen) {
	            	stage.displayState = flash.display.StageDisplayState.FULL_SCREEN_INTERACTIVE;
	   			}

            	if(configuration.showRoomSelection) {
            		chooseApplianceLbl.setVisible(true);
            		applianceChooser.setVisible(true);
            	}

            	if(configuration.debug) {
            		debugInfo.setVisible(true);
            	}
            	
            	if(configuration.hideControlButtons) {
            		controlHBox.setVisible(false);
            	}
            	
            	if(configuration.hideSettingsButton) {
            		settingsBtn.setVisible(false);
            	}
            	
            	if(!configuration.hideStartMonitoringButton) {
            		startMonitoringBtn.setVisible(true);
            	}
            	
            	if(configuration.infoRequestTimeout) {
            		infoHTTPService.requestTimeout = configuration.infoRequestTimeout;
            	}
            	
            	if(configuration.controlRequestTimeout) {
            		controlHTTPService.requestTimeout = configuration.controlRequestTimeout;
            	}
            	
            	stage.addEventListener(KeyboardEvent.KEY_DOWN, reportKeyDown);
            	stage.addEventListener(KeyboardEvent.KEY_UP, reportKeyUp);
				
				monitorArea.filters = [okGlow];
				infoHeader.filters = [okGlow];
				infoMessage.filters = [okGlow];
				
				this.addEventListener(AIREvent.APPLICATION_ACTIVATE, applicationActivate);
				this.addEventListener(AIREvent.APPLICATION_DEACTIVATE, applicationDeactivate);

				infoTimer = new Timer(configuration.infoTimerIdle, 0);
		        infoTimer.addEventListener("timer", infoTimerHandler);

				monitorImageLoader[0] = new Loader(); // Just in case :) Theoretically this should never be used
				monitorImageLoader[1] = new Loader(); // For loading the first monitoring image
				monitorImageLoader[2] = new Loader(); // For loading the second monitoring image

				controlHTTPService.contentType = "text/plain;charset=UTF-8";

				if(configuration.showFirstApplianceAutomatically) { // Check if the first appliance in the appliances list should be showed automatically
					setMonitoredAppliance();
		  		}
		    	
				stopButton1.setStyle("icon", stopIcon);
				stopButton1.setStyle("horizontalGap", 10);
				stopButton2.setStyle("icon", stopIcon);
				stopButton2.setStyle("horizontalGap", 10);
				pauseButton.setStyle("icon", pauseIcon);
				pauseButton.setStyle("horizontalGap", 10);
				extendButton.setStyle("icon", extendIcon);
				extendButton.setStyle("horizontalGap", 10);
				resumeButton.setStyle("icon", resumeIcon);
				resumeButton.setStyle("horizontalGap", 10);
            } // initApp


            // loadConfiguration
            private function loadConfiguration():void {
            	configurationFile = File.applicationStorageDirectory.resolvePath(configurationFileName);
            	debugMe("info", "Configuration file: " + configurationFile.nativePath, true);
            	if(configurationFile.exists) { // Does the configuraton file exist?
					configurationFileStream = new FileStream();
				    configurationFileStream.open(configurationFile, FileMode.READ);
				    configurationXML = XML(configurationFileStream.readUTFBytes(configurationFileStream.bytesAvailable));
					configurationFileStream.close();
					
					if(configurationXML.appliances.children().length() > 0) {
						appliances = new XMLListCollection(configurationXML.appliances.appliance);
					} else {
						Alert.show(StringUtil.substitute(resourceManager.getString("EchoMonitor","error_no_appliances_in_configuration"), configurationFile.nativePath.toString()),resourceManager.getString("EchoMonitor","error_title"),Alert.OK,this,function(e:Event):void {
            				NativeApplication.nativeApplication.exit();
            			});	
					}
					
					if(configurationXML.audioErrorLevel != undefined) {
						configuration.audioErrorLevel = int(configurationXML.audioErrorLevel);
					}
					if(configurationXML.audioErrorLimit != undefined) {
						configuration.audioErrorLimit = int(configurationXML.audioErrorLimit);
					}
					if(configurationXML.audioWarningLimit != undefined) {
						configuration.audioWarningLimit = int(configurationXML.audioWarningLimit);
					}
					if(configurationXML.controlRequestTimeout != undefined) {
						configuration.controlRequestTimeout = int(configurationXML.controlRequestTimeout);
					}
					if(configurationXML.debug != undefined) {
						configuration.debug = configurationXML.debug.toLowerCase() == "true";
					}
					if(configurationXML.audioWarningLimit != undefined) {
						configuration.audioWarningLimit = int(configurationXML.audioWarningLimit);
					}
					if(configurationXML.defaultAdHocDescription != undefined) {
						configuration.defaultAdHocDescription = String(configurationXML.defaultAdHocDescription);
					}
					if(configurationXML.defaultAdHocDuration != undefined) {
						configuration.defaultAdHocDuration = int(configurationXML.defaultAdHocDuration);
					}
					if(configurationXML.defaultAdHocProfile != undefined) {
						configuration.defaultAdHocProfile = String(configurationXML.defaultAdHocProfile);
					}
					if(configurationXML.defaultLocale != undefined) {
						configuration.defaultLocale = String(configurationXML.defaultLocale);
					}
					if(configurationXML.defaultMonitoringDuration != undefined) {
						configuration.defaultMonitoringDuration = int(configurationXML.defaultMonitoringDuration);
					}
					if(configurationXML.defaultMonitoringProfile != undefined) {
						configuration.defaultMonitoringProfile = String(configurationXML.defaultMonitoringProfile);
					}
					if(configurationXML.enableAdHocCapture != undefined) {
						configuration.enableAdHocCapture = configurationXML.enableAdHocCapture.toLowerCase() == "true";
					}
					if(configurationXML.enableCaptureControl != undefined) {
						configuration.enableCaptureControl = configurationXML.enableCaptureControl.toLowerCase() == "true";
					}
					if(configurationXML.eventSoundCaptureBeginning != undefined) {
						configuration.eventSoundCaptureBeginning = String(configurationXML.eventSoundCaptureBeginning);
						loadSound(configuration.eventSoundCaptureBeginning);
					}
					if(configurationXML.eventSoundSignalError != undefined) {
						configuration.eventSoundSignalError = String(configurationXML.eventSoundSignalError);
						loadSound(configuration.eventSoundSignalError);
					}
					if(configurationXML.hideAdHocButton != undefined) {
						configuration.hideAdHocButton = configurationXML.hideAdHocButton.toLowerCase() == "true";
					}
					if(configurationXML.hideControlButtons != undefined) {
						configuration.hideControlButtons = configurationXML.hideControlButtons.toLowerCase() == "true";
					}
					if(configurationXML.hideLiveStreamInfo != undefined) {
						configuration.hideLiveStreamInfo = configurationXML.hideLiveStreamInfo.toLowerCase() == "true";
					}
					if(configurationXML.hideSettingsButton != undefined) {
						configuration.hideSettingsButton = configurationXML.hideSettingsButton.toLowerCase() == "true";
					}
					if(configurationXML.hideSourceLabel != undefined) {
						configuration.hideSourceLabel = configurationXML.hideSourceLabel.toLowerCase() == "true";
					}
					if(configurationXML.hideStartMonitoringButton != undefined) {
						configuration.hideStartMonitoringButton = configurationXML.hideStartMonitoringButton.toLowerCase() == "true";
					}
					if(configurationXML.hideVUMeter != undefined) {
						configuration.hideVUMeter = configurationXML.hideVUMeter.toLowerCase() == "true";
					}
					if(configurationXML.ignoreMissingDisplaySignal != undefined) {
						configuration.ignoreMissingDisplaySignal = configurationXML.ignoreMissingDisplaySignal.toLowerCase() == "true";
					}
					if(configurationXML.ignoreMissingVideoSignal != undefined) {
						configuration.ignoreMissingVideoSignal = configurationXML.ignoreMissingVideoSignal.toLowerCase() == "true";
					}
					if(configurationXML.infoRequestTimeout != undefined) {
						configuration.infoRequestTimeout = int(configurationXML.infoRequestTimeout);
					}
					if(configurationXML.infoTimerActive != undefined) {
						configuration.infoTimerActive = int(configurationXML.infoTimerActive);
					}
					if(configurationXML.infoTimerIdle != undefined) {
						configuration.infoTimerIdle = int(configurationXML.infoTimerIdle);
					}
					if(configurationXML.showFirstApplianceAutomatically != undefined) {
						configuration.showFirstApplianceAutomatically = configurationXML.showFirstApplianceAutomatically.toLowerCase() == "true";
					}
					if(configurationXML.showRoomSelection != undefined) {
						configuration.showRoomSelection = configurationXML.showRoomSelection.toLowerCase() == "true";
					}
					if(configurationXML.startFullscreen != undefined) {
						configuration.startFullscreen = configurationXML.startFullscreen.toLowerCase() == "true";
					}
					
					// debugMe("info", configurationXML.toString());
            	} else { // The configuration file does not exist
					setUpConfigurationFile(); // Set up the configuration file
            	}
            } // private function loadConfiguration():void {


			private function loadSound(soundFile:String):void {
				eventSound[soundFile] = new Sound();
				eventSound[soundFile].addEventListener(Event.COMPLETE, onLoadComplete);
				eventSound[soundFile].addEventListener(IOErrorEvent.IO_ERROR, onIOError);
				var req:URLRequest = new URLRequest("file://" + File.applicationStorageDirectory.nativePath + "/" + soundFile);
				eventSound[soundFile].load(req);
			}


			private function onLoadComplete(event:Event):void 
			{ 
			    var localSound:Sound = event.target as Sound;
			}


			private function onIOError(event:IOErrorEvent):void
			{ 
			    debugMe("error", "The sound could not be loaded: " + event.text, true); 
			}


            // setUpConfigurationFile
            private function setUpConfigurationFile():void {
            	if(!configurationFile.exists)
            	{
            		if(File.applicationDirectory.resolvePath(configurationFileName).exists) {
            			File.applicationDirectory.resolvePath(configurationFileName).copyTo(configurationFile)
						Alert.show(StringUtil.substitute(resourceManager.getString("EchoMonitor","error_configuration_file_missing"), configurationFile.nativePath.toString()),resourceManager.getString("EchoMonitor","error_title"),Alert.OK,this,function(e:Event):void {
        					NativeApplication.nativeApplication.exit();
        				});
            		} else if(File.applicationDirectory.resolvePath("default_" + configurationFileName).exists) {
            			File.applicationDirectory.resolvePath("default_" + configurationFileName).copyTo(configurationFile)
						Alert.show(StringUtil.substitute(resourceManager.getString("EchoMonitor","error_configuration_file_missing"), configurationFile.nativePath.toString()),resourceManager.getString("EchoMonitor","error_title"),Alert.OK,this,function(e:Event):void {
        					NativeApplication.nativeApplication.exit();
        				});
            		} // if(File.applicationDirectory.resolvePath(configurationFileName).exists)
            	} else {
            		// TODO
            		// What if the configuration file exists?
            	} // if(!configurationFile.exists)
            } // private function setUpConfigurationFile():void {

            
            // infoTimerHandler
            private function infoTimerHandler(event:TimerEvent):void {
            	infoHTTPService.send();
            } // private function infoTimerHandler(event:TimerEvent):void {


            // infoHandler
            private function infoHandler(event:ResultEvent):void {
                var result:XML = event.result as XML;
                var now:Date = new Date();
                var startTime:Date;
                var durationInMinutes:int;
                var difference:Number;
                var minutesToNextCapture:int;
                var hoursToNextCapture:int;
                
                deactivateInfoBox(); // Hide infoBox
            	networkErrorCount = 0; // Set the error count of network errors to 0
                
				debugMe("info","Result XML from infoHandler:\n" + result);
                
                // Check if there is a  current capture scheduled?
                if(result.current.schedule.parameters != undefined) {
                	startTime = isoToDate(result.current.schedule.child("start-time"));
                	durationInMinutes = int(result.current.duration)/60;
	               	var captureEnd:Number = startTime.getTime()+(result.current.duration*1000);
	                var secondsToCaptureEnd:Number = Math.round((captureEnd-now.getTime())/1000);
	                
	                // Is there an active capture going on at the moment?
                	if(result.current.state == "active") {
                		captureState = "active";

                		infoTimer.delay = configuration.infoTimerActive;
                		
	                	activateMonitoring(result);
	                	
	                	if(secondsToCaptureEnd >= 59)
	                	{
	                		// infoTimer.delay = infoTimerIdle;
		                	mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","active_capture_for_more_than_1_minute"), Math.round(secondsToCaptureEnd/60).toString());
		                } else if(secondsToCaptureEnd > 0) {
		                	// infoTimer.delay = infoTimerActive;
		                	mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","active_capture_ending_in_less_than_1_minute"), secondsToCaptureEnd.toString());
		                } else if(secondsToCaptureEnd <= 0) {
		                	mainInfo.text = resourceManager.getString("EchoMonitor","capture_is_stopping");
		                }
	                	secondaryInfo.text = "\"" + result.current.schedule.parameters.title + "\"";
                	} else if(result.current.state == "paused") {
                		captureState = "paused";

	                	deactivateMonitoring();

	                	mainInfo.text = resourceManager.getString("EchoMonitor","active_capture_has_been_paused");
	                	secondaryInfo.text = "\"" + result.current.schedule.parameters.title + "\"";

	                	if(!configuration.hideControlButtons) {
	                		resumeHBox.setVisible(true);
	                	}
	                } else if(result.current.schedule.parameters != undefined && result.current.state == "waiting") {
	                	captureState = "waiting";

	                	deactivateMonitoring();

	                	infoTimer.delay = configuration.infoTimerActive;
	                	difference = startTime.getTime()-now.getTime();
	        	        var secondsToNextCapture:int = Math.round(difference/1000);
	        	        minutesToNextCapture = Math.round(difference/minute);
	                	if(secondsToNextCapture > 90) {
							mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_less_than_1_hour"), minutesToNextCapture.toString());
            	    	} else if(secondsToNextCapture > 60) {
							mainInfo.text = resourceManager.getString("EchoMonitor","next_capture_in_about_1_minute");
            	    	} else if(secondsToNextCapture > 0) {
            	    		mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_seconds"), secondsToNextCapture.toString());
            	    	} else if(secondsToNextCapture <= 0) {
            	    		mainInfo.text = resourceManager.getString("EchoMonitor","capture_is_starting");
            	    	}
	                	secondaryInfo.text = "\"" + result.current.schedule.parameters.title + "\"\n" + dateFormatter.format(startTime) + " @ " + timeFormatter.format(startTime) + " / " + durationInMinutes + " " + resourceManager.getString("EchoMonitor","minutes");
	                }
                } else if(result.next.parameters != undefined) { // Is there a capture scheduled in the future?
                	captureState = null;

                	deactivateMonitoring();

                	infoTimer.delay = configuration.infoTimerIdle;
	                startTime = isoToDate(result.next.child("start-time"));
        	        difference = startTime.getTime()-now.getTime();
        	        minutesToNextCapture = Math.round(difference/minute);
        	        hoursToNextCapture = Math.round(difference/hour);
					var daysToNextCapture:int = Math.round(difference/day);
					var a:int, b:int;
					durationInMinutes = int(result.next.child("duration"))/60;

            	    if(difference/day < 1) {
            	    	if(minutesToNextCapture >= 60) {
            	    		a = Math.floor(minutesToNextCapture / 60);
            	    		b = minutesToNextCapture - (a*60);
            	    		mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_more_than_1_hour"), a.toString(), b.toString());
            	    	} else if(minutesToNextCapture > 1) {
							mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_less_than_1_hour"), minutesToNextCapture.toString());
            	    	} else if(minutesToNextCapture == 1) {
							mainInfo.text = resourceManager.getString("EchoMonitor","next_capture_in_about_1_minute");
            	    	} else if(minutesToNextCapture < 1) {
            	    		mainInfo.text = resourceManager.getString("EchoMonitor","next_capture_in_less_than_1_minute");
            	    	}
	                } else {
	                	a = Math.floor(hoursToNextCapture / 24);
	                	b = hoursToNextCapture - (a * 24);
						mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_days"), a.toString(), b.toString());
        	        }
        	        
        	        secondaryInfo.text = "\"" + result.next.parameters.title + "\"\n" + dateFormatter.format(startTime) + " @ " + timeFormatter.format(startTime) + " / " + durationInMinutes + " " + resourceManager.getString("EchoMonitor","minutes");;
        	    } else {
        	    	captureState = null;

        	    	deactivateMonitoring();

        	    	infoTimer.delay = configuration.infoTimerIdle;

        	    	mainInfo.text = resourceManager.getString("EchoMonitor", "no_next_capture");
        	    	secondaryInfo.text = "";
        	    }
        	    
        	    if(networkErrorCount == 0 && captureState === null && configuration.enableCaptureControl && configuration.enableAdHocCapture) {
        	    	adhocHBox.setVisible(true);
        	    } else {
        	    	adhocHBox.setVisible(false);
        	    }
        	    
        	    var setFrom:String;
        	    
        	    if(adHocProfile == false || adHocProfile == null || adHocProfile == "") {
        	    	setFrom = "";
        	    	if((configuration.defaultAdHocProfile != "" && configuration.defaultAdHocProfile !== null) || applianceDefaultAdHocProfile !== null) {
        	    		if(applianceDefaultAdHocProfile !== null) {
        	    			adHocProfile = applianceDefaultAdHocProfile;
        	    			setFrom = "applianceDefaultAdHocProfile";
        	    		} else {
	        	    		adHocProfile = configuration.defaultAdHocProfile;
	        	    		setFrom = "defaultAdHocProfile";
	        	    	}
        	    	} else if(result.child("monitor-profiles").child("monitor-profile") != undefined) {
	        	    	adHocProfile = result.child("monitor-profiles").child("monitor-profile");
	        	    	setFrom = "monitor-profiles";
	        	    } else {
	        	    	adHocProfile = null;
	        	    }
	        	    debugMe("info", "Ad-Hoc Profile has been set from \"" + setFrom + "\" to: " + adHocProfile, true);
        	    }
        	    
        	    if(monitoringProfile == false || monitoringProfile == null || monitoringProfile == "") {
        	    	setFrom = "";
        	    	if((configuration.defaultMonitoringProfile != "" && configuration.defaultMonitoringProfile !== null) || applianceDefaultMonitoringProfile !== null) {
        	    		if(applianceDefaultMonitoringProfile !== null) {
	        	    		monitoringProfile = applianceDefaultMonitoringProfile;
	        	    		setFrom = "applianceDefaultMonitoringProfile";
	        	    	} else {
	        	    		monitoringProfile = configuration.defaultMonitoringProfile;
	        	    		setFrom = "defaultMonitoringProfile";
	        	    	}
        	    	} else if(result.child("monitor-profiles").child("monitor-profile") != undefined) {
	        	    	monitoringProfile = result.child("monitor-profiles").child("monitor-profile");
	        	    	setFrom = "monitor-profiles";
	        	    } else {
	        	    	monitoringProfile = null;
	        	    }
	        	    debugMe("info", "Monitoring Profile has been set from \"" + setFrom + "\" to: " + monitoringProfile, true);
        	    }
        	    if(configurationInfo.text == "") {
        	    	configurationInfo.text = "Available capture profiles on this capture device (one profile per line):\n";
        	    	var captureProfiles:XMLList = result.child("capture-profiles").child("capture-profile");
        	    	var captureProfile:XML;
        	    	for each(captureProfile in captureProfiles) {
        	    		configurationInfo.text += captureProfile.toString() + "\n";
        	    	}
        	    	configurationInfo.text += "\nDefault monitoring profile of this capture device:\n";
        	    	var monitoringProfiles:XMLList = result.child("monitor-profiles").child("monitor-profile");
        	    	configurationInfo.text += monitoringProfiles[0].toString() + "\n";
        	    }
            } // private function infoHandler(event:ResultEvent):void {


            // monitorHandler
            private function monitorHandler(result:XML):void {
            	if(result.current.state == "active" || result.current.child("confidence-monitoring") == "true" ) {
            		if(!monitorArea.visible) {
	            		monitorArea.setVisible(true);
            		}
            		
            		var warning:Boolean = false;
            		var error:Boolean = false;
                	var randString:String = new Date().getTime().toString();
                	
                	var audioResult:XMLList = result.current.sources.source.(child("class").toString().search("audio")>-1);
                	var audioPeakLevel:int = audioResult.channels.channel[1].peak;

                	if(audioResult.child("signal-present") == "false" || audioPeakLevel <= configuration.audioErrorLevel) { // Audio signal missing
                		audioErrorCount++;
                		if(audioErrorCount > configuration.audioWarningLimit) {
                			if(audioErrorCount > configuration.audioErrorLimit) {
                				error = true;
                			} else {
                				warning = true;
                			}
	                		if(!checkAudio.visible) {
	                			checkAudio.setVisible(true);
	                		}
	                	}
                	} else { // Audio signal present
                		audioErrorCount = 0;
                		if(checkAudio.visible) {
                			checkAudio.setVisible(false);
                		}
                	}
                	
                	// Set audio level meter (VU Meter)
                	if(!configuration.hideVUMeter) { // Should the audio VU meter be shown?
                		// Set the VU meter by moving the partly transparent rectangle on the VU meter image
	                	audioInputLevel.y = audioInputLevelVUMeter.y - (audioPeakLevel * (240 / 32768));
                		// Set the VU meter visible
                		audioInputLevel.setVisible(true);
	                	audioInputLevelVUMeter.setVisible(true);
	                } else { // or should the audio VU meter be hidden?
	                	// Hide the VU meter
	                	audioInputLevel.setVisible(false);
	                	audioInputLevelVUMeter.setVisible(false);
	                }

					var sources:XMLList = result.current.sources.source;
					var monitorUsed:Number = 1;
					var inputMonitor:Object;
					var monitorLabel:Object;
					var monitorError:Object;
					var monitorImageName:String;
                	for(var i:Number = 0; i < 3; i++) {
                		inputMonitor = this["inputMonitor" + monitorUsed];
            			monitorLabel = this["monitor" + monitorUsed + "Label"];
            			monitorError = this["monitor" + monitorUsed + "Error"];
                		if(sources[i] && (sources[i].child("class") == "video" || sources[i].child("class") == "vga")) {
                			if(sources[i].child("signal-present") == "true" || (sources[i].child("class") == "video" && configuration.ignoreMissingVideoSignal) || (sources[i].child("class") == "display" && configuration.ignoreMissingDisplaySignal)) {
                				if(monitorError.visible) { // Check if the source error message is visible
	                				monitorError.setVisible(false); // Hide source error message
	                			}
	                			
	                			if(sources[i].child("class") == "video") {
	                				monitorLabel.text = resourceManager.getString('EchoMonitor', 'video');
	                			} else {
	                				monitorLabel.text = resourceManager.getString('EchoMonitor', 'display');
	                			}
	                			
	                			if(configuration.hideSourceLabel) { // Check if the source label should be hidden
		                			monitorLabel.setVisible(false); // Hide the source label
		                		} else {
		                			monitorLabel.setVisible(true); // Show the source label
		                		}
		                		
			                	monitorImageName = sources[i].child("thumbnail"); // Get the thumbnail image name
			                	if(monitorImageName.length == 0) { // Check if the thumbnail image name has not been set
			                		monitorImageName = "video_pal_4.jpg"; // Set the thumbnail image name to video_pal_4.jpg
			                	}
			                	getMonitorImage(monitorUsed, applianceURL + "/monitoring/" + monitorImageName + "?" + randString, inputMonitor);
                			} else {
                				error = true;
	                			monitorLabel.setVisible(false); // Hide the source label
	                			inputMonitor.setVisible(false);
	                			if(sources[i].child("class") == "video") {
	                				monitorError.text = resourceManager.getString('EchoMonitor', 'video_missing');
	                			} else {
	                				monitorError.text = resourceManager.getString('EchoMonitor', 'display_missing');
	                			}
	                			if(!monitorError.visible) {
	                				monitorError.setVisible(true);
	                			}
                			}
                			
                			monitorUsed++;
                		} else if (sources[i] && sources[i].child("class") != "audio") {
                			if(monitorLabel) {
                				monitorLabel.setVisible(false); // Hide the source label
                			}
                			if(monitorError) {
                				monitorError.setVisible(false); // Hide the error message
                			}
                			if(inputMonitor) {
                				inputMonitor.setVisible(false);
                			}
                		}
                		
                		// Check if the current capture is LIVE and notify the user about it
                		var outputType:String = result.current.child("output-type").toString();
                		if(!configuration.hideLiveStreamInfo && outputType.indexOf("live") >= 0) { // Is the current capture LIVE?
                			// Capture is LIVE
                			if(!captureIsLive.visible) { // Is the LIVE text visible? 
                				captureIsLive.setVisible(true); // Set the LIVE text visible
                			}
                		} else {
                			// Capture is not LIVE
                			if(captureIsLive.visible) {
                				captureIsLive.setVisible(false); // Hide the LIVE text
                			}
                		}
                	}

					/*                	
					var capturedSources:String = String(result.current.schedule.parameters.child("name-key"));
            		if(capturedSources.length == 0) {
            			capturedSources = "audio-display-video";
            		}
            		
                	if(capturedSources.search("video") >= 0) {
	                	var videoResult:XMLList = result.current.sources.source.(child("class").toString().search("video")>-1);
	                	if(videoResult.child("signal-present") == "true") { // Video signal present
	                		if(monitor1Error.visible) {
	                			monitor1Error.setVisible(false);
	                		}
		                	monitor1Label.setVisible(true);
		                	monitorImageName = videoResult.child("thumbnail");
		                	if(monitorImageName.length == 0) {
		                		monitorImageName = "video_pal_4.jpg";
		                	}
		                	getMonitorImage("video", applianceURL + "/monitoring/" + monitorImageName + "?" + randString, inputMonitor1);
	                	} else { // Video signal missing
	                		error = true;
	                		mon1Label.setVisible(false);
	                		inputMonitor1.setVisible(false);
	                		if(!mon1Error.visible) {
	                			mon1Error.setVisible(true);
	                		}
	                	}
	                } else {
	                	mon1Label.setVisible(false);
	                	inputMonitor1.setVisible(false);
	                	mon1Error.setVisible(false);
	                }
                	
                	if(capturedSources.search("display") >= 0) {
	                	var displayResult:XMLList = result.current.sources.source.(child("class").toString().search("vga")>-1);
	                	if(displayResult.child("signal-present") == "true") { // Display signal present
	                		if(mon2Error.visible) {
	                			mon2Error.setVisible(false);
	                		}
		                	mon2Label.setVisible(true);
		                	monitorImageName = displayResult.child("thumbnail");
		                	if(monitorImageName.length == 0) {
		                		monitorImageName = "vga_display_1.jpg";
		                	}
		                	getMonitorImage("display", applianceURL + "/monitoring/" + monitorImageName + "?" + randString, inputMonitor2);
		                } else { // Display signal missing
		                	error = true;
		                	mon2Label.setVisible(false);
		                	inputMonitor2.setVisible(false);
		                	if(!mon2Error.visible) {
		                		mon2Error.setVisible(true);
		                	}
		                }
                	} else {
                		mon2Label.setVisible(false);
                		inputMonitor2.setVisible(false);
                		mon2Error.setVisible(false);
                	}
					*/

					if(!warning && !error) {
						if(doGlow.isPlaying) {
							doGlow.stop();
						}
						monitorArea.filters = [okGlow];
					} else if(error) {
						if(!doGlow.isPlaying) {
							doGlow.play([monitorArea]);
						}
					} else {
						monitorArea.filters = [warningGlow];
					}
                } else {
                	if(monitorArea.visible) {
                		monitorArea.setVisible(false);
                	}

                	monitor1Label.setVisible(false);
                	inputMonitor1.setVisible(false);
                	monitor2Label.setVisible(false);
                	inputMonitor2.setVisible(false);
                }
            } // monitorHandler
            
            
            // controlHandler
            private function controlHandler(event:ResultEvent):void {
                var result:XML = event.result as XML;
            } // controlHandler


            // httpFault
            private function httpFault(source:String, event:FaultEvent):void {
            	if(event.fault.faultCode == "Server.Error.Request") {
            		networkErrorCount++;
            	}
            	
            	if(networkErrorCount > 3) {
            		activateInfoBox("httpFault");
            	}
            	
                debugMe("error", "httpFault: (" + source + ") " + event.fault.faultString + " [" + event.fault.faultCode + "] " + event.message);
            } // httpFault


            private function activateInfoBox(type:String, message:String = ""):void {
            	if(type == "httpFault") {
					infoHeader.text = resourceManager.getString('EchoMonitor', 'connection_error_header');
					infoMessage.text = resourceManager.getString('EchoMonitor', 'connection_error_message');
					middleVBox.filters = [blurredBox];
					infoBox.setVisible(true);
            	} else if(type == "pleasewait") {
            		infoHeader.text = resourceManager.getString('EchoMonitor', 'please_wait');
            		infoMessage.text = message;
            		middleVBox.filters = [blurredBox];
            		infoBox.setVisible(true);
            	}
            } // activateInfoBox


            private function deactivateInfoBox():void {
            	middleVBox.filters = null;
            	infoBox.setVisible(false);
            	resumeHBox.setVisible(false);
            } // deactivateInfoBox


            // getMonitorImage
			private function getMonitorImage(inputMonitorImageNum:Number, address:String, toImage:Object):void {
	            var request:URLRequest = new URLRequest(encodeURI(address));
	            request.method = URLRequestMethod.POST; // Set the methof (POST) for the upcoming request
	            request.requestHeaders.push(monitorImageRequestHeader); // Set the authentication header for the upcoming request
				var _loader:Loader; // Initiate new loader
        		monitorImageLoader[inputMonitorImageNum].unload(); // Clear previous loading information
        		_loader = monitorImageLoader[inputMonitorImageNum];
        		if(!_loader.contentLoaderInfo.hasEventListener(Event.COMPLETE)) {
					_loader.contentLoaderInfo.addEventListener(Event.COMPLETE,function(e:Event):void{ 
						toImage.source = e.currentTarget.content;
						if(!toImage.visible) {
							toImage.setVisible(true);
						}
						var imageWidth:int = e.currentTarget.width;
						var imageHeight:int = e.currentTarget.height;
						var imageAspectRatio:Number = imageWidth / imageHeight;
						var newImageHeight:int = (imageHeight >= 240) ? 240 : imageHeight;
						var newImageWidth:int = (imageHeight >= 240) ? 240 * imageAspectRatio : imageWidth;
						if(toImage.width != newImageWidth || toImage.height != newImageHeight) {
							toImage.width = newImageWidth;
							toImage.height = newImageHeight;
							if(toImage.id == "inputMonitor1") {
								//inputMonitor1_hc = -185;
							} else {
								//inputMonitor2_hc = 185;
							}
							//toImage.verticalCenter = 20;
						}
					});
        		}
				_loader.load(request);
			} // getMonitorImage


			// applyLocale
			private function applyLocale(e:Event):void {
	        //    dateValue = dateFormatter.format(d);
	        //    timeValue = timeFormatter.format(d);
	        //    currencyValue = currencyFormatter.format(1000);
	        } // applyLocale


			// getTimestamp
            private function getTimestamp(date:Date):Number {
				var unixTime:Number = Math.round(date.getTime()/1000);
				return unixTime;
			} // getTimestamp


            // isoToDate
            private function isoToDate(value:String):Date {
                var dateStr:String = value;
                dateStr = dateStr.replace(/\-/g, "/");
                dateStr = dateStr.replace("T", " ");
                dateStr = dateStr.replace("Z", " GMT-0000");
                dateStr = dateStr.replace(".000", "");
                return new Date(Date.parse(dateStr));
            } // isoToDate


            // getBase64UsernamePassword
            private function getBase64UsernamePassword():String {
            	var encoder:Base64Encoder = new Base64Encoder();
        		encoder.insertNewLines = false;
				encoder.encode(username + ":" + password);
				return encoder.toString();
            } // getBase64UsernamePassword


            // setMonitoredAppliance
            private function setMonitoredAppliance():void {
            	applianceURL = applianceChooser.selectedItem.address;
            	username = applianceChooser.selectedItem.username;
            	password = applianceChooser.selectedItem.password;
            	var base64UsernamePassword:String = getBase64UsernamePassword();
            	
            	adHocProfile = null;
            	monitoringProfile = null;
            	configurationInfo.text = "";
            	
            	if(applianceChooser.selectedItem.adHocProfile !== undefined && applianceChooser.selectedItem.adHocProfile.toString().length > 0) {
            		applianceDefaultAdHocProfile = applianceChooser.selectedItem.adHocProfile;
            	} else {
            		applianceDefaultAdHocProfile = null;
            	}
            	
            	if(applianceChooser.selectedItem.monitoringProfile !== undefined && applianceChooser.selectedItem.monitoringProfile.toString().length > 0) {
            		applianceDefaultMonitoringProfile = applianceChooser.selectedItem.monitoringProfile;
            	} else {
            		applianceDefaultMonitoringProfile = null;
            	}
            	
            	infoHTTPService.url = applianceURL + "/status/captures";
				infoHTTPService.headers = {Authorization:"Basic " + base64UsernamePassword};
            	infoHTTPService.send();
            	
            	if(!infoTimer.running) {
            		infoTimer.start();
            	}
            	
            	controlHTTPService.headers = {Authorization:"Basic " + base64UsernamePassword};

	            monitorImageRequestHeader = new URLRequestHeader("Authorization","Basic " + base64UsernamePassword);
            	
            	debugMe("info", "Appliance selected: " + applianceChooser.selectedItem.name + " (" + applianceURL + ")");
			} // setMonitoredAppliance


			// activateMonitoring
			private function activateMonitoring(result:XML):void {
				if(!configuration.hideControlButtons) {
					controlHBox.setVisible(true);
				}
				monitorHandler(result);
			} // activateMonitoring


			// deactivateMonitoring
			private function deactivateMonitoring():void {
				if(monitorArea.visible) {
					monitorArea.setVisible(false);
				}
				if(doGlow.isPlaying) {
					doGlow.stop();
				}
				
				controlHBox.setVisible(false);
				
				monitorArea.filters = [okGlow];
				audioErrorCount = 0;
        		if(checkAudio.visible) {
        			checkAudio.setVisible(false);
        		}
        		if(monitor1Label.visible) {
        			monitor1Label.setVisible(false);
        		}
        		if(monitor1Error.visible) {
        			monitor1Error.setVisible(false);
        		}
        		if(inputMonitor1.visible) {
        			inputMonitor1.setVisible(false);
        		}
        		if(monitor2Label.visible) {
        			monitor2Label.setVisible(false);
        		}
        		if(monitor2Error.visible) {
        			monitor2Error.setVisible(false);
        		}
        		if(inputMonitor2.visible) {
        			inputMonitor2.setVisible(false);
        		}
			} // deactivateMonitoring


			// changeView
			private function changeView():void {
				if(stage.displayState != StageDisplayState.NORMAL) {
					stage.displayState = StageDisplayState.NORMAL;
					changeViewBtn.label = resourceManager.getString("EchoMonitor", "fullscreen");
				} else {
					stage.displayState = StageDisplayState.FULL_SCREEN_INTERACTIVE;
					changeViewBtn.label = resourceManager.getString("EchoMonitor", "exit_fullscreen");
				}
			} // changeView


			// setLocale
			private function setLocale(locale:String):void {
				resourceManager.localeChain = [locale];
			} // setLocale


			// debugMe
			private function debugMe(type:String, debugString:String, force:Boolean = false):void {
				if((configuration.debug && debugString.length > 0) || (force && debugString.length > 0)) {
					var now:Date = new Date();
					debugInfo.text += dateFormatter.format(now) + " " + timeWithSecondsFormatter.format(now) + ":\n" + debugString + "\n ----- \n";
					if(!configuration.debug) {
						debugInfo.setVisible(false);
					}
				}
			} // debugMe


			// applicationActivate
			private function applicationActivate(event:Event):void {
			    stage.frameRate = 12;
			} // applicationActivate


			// applicationDeactivate
			private function applicationDeactivate(event:Event):void {
			    stage.frameRate = 1;
			} // applicationDeactivate


			// startCapture
			private function startCapture(type:String = "monitoring"):void {
				if(configuration.enableCaptureControl) {
					if(!(captureState == "active" || captureState == "paused" || captureState == "waiting")) {
						if(adHocProfile !== null || monitoringProfile !== null) {
							var description:String = "Capture";
							var duration:int = 900;
							var capture_profile_name:String = "";
							if(type == "ad-hoc" && configuration.enableAdHocCapture && adHocProfile !== null) {
								capture_profile_name = encodeURIComponent(adHocProfile);
								var replaceTime:RegExp = /%t/gi;
								var replaceRoom:RegExp = /%r/gi;
								var now:Date = new Date();
								description = configuration.defaultAdHocDescription;
								description = description.replace(replaceTime, dateFormatter.format(now) + " @ " + timeFormatter.format(now));
								description = description.replace(replaceRoom, applianceChooser.selectedItem.name);
								duration = configuration.defaultAdHocDuration;
								controlHTTPService.url = applianceURL + "/capture/new_capture";
								adhocHBox.setVisible(false);
								activateInfoBox("pleasewait", resourceManager.getString("EchoMonitor","starting_adhoc") + "\n\"" + description + "\"");
							} else if(type == "monitoring" && monitoringProfile !== null) {
								capture_profile_name = encodeURIComponent(monitoringProfile);
								description = "Confidence Monitoring";
								duration = configuration.defaultMonitoringDuration;
								controlHTTPService.url = applianceURL + "/capture/confidence_monitor";
								activateInfoBox("pleasewait", resourceManager.getString("EchoMonitor","monitoring_is_starting"));
							} else {
								controlHTTPService.url = applianceURL + "/status";
							}
							controlHTTPService.send('description="' + encodeURIComponent(description) + '"&duration="' + duration.toString() + '"&capture_profile_name="' + capture_profile_name + '"');
						} else {
							debugMe("error", "No capture profile (defaultAdHocProfile or defaultMonitoringProfile) was found! It is not possible to start a capture without a capture profile specified.");
						}
					} else {
						debugMe("error", "Can't start a new capture while another capture is underway!");
					}
				} else {
					debugMe("error", "Can't start a new capture! Starting captures is not enabled (enableCaptureControl=false) in EchoMonitor configuration!");
				}

			} // startCapture


			// reportKeyDown
			private function reportKeyDown(e:KeyboardEvent):void {
            	switch(e.keyCode) {
            		case Keyboard.A:
            			KeysDown.A = true;
            			break;
            		case Keyboard.B:
            			KeysDown.B = true;
            			break;
            		case Keyboard.CONTROL:
            			KeysDown.CONTROL = true;
            			break;
            		case Keyboard.D:
            			KeysDown.D = true;
            			break;
            		case Keyboard.E:
            			KeysDown.E = true;
            			break;
            		case Keyboard.F:
            			KeysDown.F = true;
            			break;
					case Keyboard.H:
            			KeysDown.H = true;
            			break;
            		case Keyboard.I:
            			KeysDown.I = true;
            			break;
            		case Keyboard.L:
            			KeysDown.L = true;
            			break;
            		case Keyboard.M:
            			KeysDown.M = true;
            			break;
            		case Keyboard.P:
            			KeysDown.P = true;
            			break;
            		case Keyboard.R:
            			KeysDown.R = true;
            			break;
            		case Keyboard.S:
            			KeysDown.S = true;
            			break;
            		case Keyboard.SHIFT:
            			KeysDown.SHIFT = true;
            			break;
            		case Keyboard.V:
            			KeysDown.V = true;
            			break;
            	}
            	checkKeys();
            } // reportKeyDown


            // reportKeyUp
            private function reportKeyUp(e:KeyboardEvent):void {
            	switch(e.keyCode) {
            		case Keyboard.A:
            			KeysDown.A = false;
            			break;
            		case Keyboard.B:
            			KeysDown.B = false;
            			break;
            		case Keyboard.CONTROL:
            			KeysDown.CONTROL = false;
            			break;
            		case Keyboard.D:
            			KeysDown.D = false;
            			break;
            		case Keyboard.E:
            			KeysDown.E = false;
            			break;
            		case Keyboard.F:
            			KeysDown.F = false;
            			break;
					case Keyboard.H:
            			KeysDown.H = false;
            			break;
            		case Keyboard.I:
            			KeysDown.I = false;
            			break;
            		case Keyboard.L:
            			KeysDown.L = false;
            			break;
            		case Keyboard.M:
            			KeysDown.M = false;
            			break;
            		case Keyboard.P:
            			KeysDown.P = false;
            			break;
            		case Keyboard.R:
            			KeysDown.R = false;
            			break;
            		case Keyboard.S:
            			KeysDown.S = false;
            			break;
            		case Keyboard.SHIFT:
            			KeysDown.SHIFT = false;
            			break;
            		case Keyboard.V:
            			KeysDown.V = false;
            			break;
            	}
				checkKeys();
            } // reportKeyUp


            // checkKeys
            private function checkKeys():void {
            	if(KeysDown.CONTROL && KeysDown.SHIFT && KeysDown.A) { // Starts an Ad-Hoc capture if CTRL+A is pressed on the keyboard
            		startCapture("ad-hoc");
            	} else if(KeysDown.CONTROL && KeysDown.B) { // Hides or shows the capture control buttons if CTRL+B is pressed on the keyboard
            		configuration.hideControlButtons = !configuration.hideControlButtons;
            		if(captureState == "active" && !configuration.hideControlButtons) {
            			resumeHBox.setVisible(false);
            			controlHBox.setVisible(true);
            		} else if (captureState == "paused" && !configuration.hideControlButtons) {
            			resumeHBox.setVisible(true);
            			controlHBox.setVisible(false);
            		}
            		if(configuration.hideControlButtons) {
            			resumeHBox.setVisible(false);
            			controlHBox.setVisible(false);
            		}
            	} else if(KeysDown.CONTROL && KeysDown.D) { // Hides or shows the debugging area if CTRL+D is pressed on the keyboard
            		configuration.debug = !configuration.debug;
            		debugInfo.visible = !debugInfo.visible;
            	} else if(KeysDown.CONTROL && KeysDown.E) { // Extends the capture if CTRL+E is pressed on the keyboard
					actionClick("extend");
            	} else if(KeysDown.CONTROL && KeysDown.F) { // Toggles fullscreen if CTRL+F is pressed on the keyboard
            		changeView();
				} else if(KeysDown.CONTROL && KeysDown.H) { // Hides or shows the top control bar if CTRL+H is pressed on the keyboard
            		monitorControlBar.visible = !monitorControlBar.visible;
            	} else if(KeysDown.CONTROL && KeysDown.I) { // Hides or shows the info box if CTRL+I is pressed on the keyboard
            		configurationInfo.visible = !configurationInfo.visible;
            	} else if(KeysDown.CONTROL && KeysDown.L) { // Hides or shows the source label on the monitoring images if CTRL+L is pressed on the keyboard
            		configuration.hideSourceLabel = !configuration.hideSourceLabel;
            	} else if(KeysDown.CONTROL && KeysDown.M) { // Starts a monitoring session if CTRL+M is pressed on the keyboard
            		startCapture("monitoring");
            	} else if(KeysDown.CONTROL && KeysDown.P) { // Pauses the capture if CTRL+P is pressed on the keyboard
            		actionClick("pause");
            	} else if(KeysDown.CONTROL && KeysDown.R) { // Resumes the capture if CTRL+R is pressed on the keyboard
            		actionClick("record");
            	} else if(KeysDown.CONTROL && KeysDown.S) { // Stops the capture if CTRL+S is pressed on the keyboard
            		actionClick("stop");
            	} else if(KeysDown.CONTROL && KeysDown.SHIFT && KeysDown.V) { // Hides or shows the VU Meter if CTRL+SHIFT+V are pressed on the keyboard
            		configuration.hideVUMeter = !configuration.hideVUMeter;
            	}
            } // checkKeys


            // openSettings
            private function openSettings():void {
            	Alert.show(StringUtil.substitute(resourceManager.getString("EchoMonitor","configuration_location"), configurationFile.parent.nativePath.toString()));
            	//navigateToURL(new URLRequest("file:///" + configurationFile.parent.nativePath));
            } // openSettings
            
            
            // actionClick
            private function actionClick(target:String):void {
            	if(configuration.enableCaptureControl) {
	            	const dummyObject:Object = { "dummy" : "object" };
	            	if(target === "stop") {
	            		if(captureState == "active" || captureState == "paused" || captureState == "waiting") {
		            		controlHTTPService.url = applianceURL + "/capture/stop";
		            		debugMe("info", "Sending action " + target + " (" + controlHTTPService.url.toString() + ") to control current capture!");
		            		activateInfoBox("pleasewait", resourceManager.getString("EchoMonitor","stopping_capture"));
		            		controlHTTPService.send(dummyObject);
	            		} else {
	            			debugMe("error", "The action " + target + " can't be run in the state " + captureState + "!");
	            		}
	            	} else if (target === "pause") {
	            		if(captureState == "active") {
		            		controlHTTPService.url = applianceURL + "/capture/pause";
		            		debugMe("info", "Sending action " + target + " (" + controlHTTPService.url.toString() + ") to control current capture!");
		            		activateInfoBox("pleasewait", resourceManager.getString("EchoMonitor","pausing_capture"));
		            		controlHTTPService.send(dummyObject);
	            		} else {
	            			debugMe("error", "The action " + target + " can't be run in the state " + captureState + "!");
	            		}
	            	} else if (target === "extend") {
	            		if(captureState == "active") {
		            		controlHTTPService.url = applianceURL + "/capture/extend";
		            		debugMe("info", "Sending action " + target + " (" + controlHTTPService.url.toString() + ") to control current capture!");
		            		activateInfoBox("pleasewait", resourceManager.getString("EchoMonitor","extending_capture"));
		            		controlHTTPService.send(dummyObject);
	            		} else {
	            			debugMe("error", "The action " + target + " can't be run in the state " + captureState + "!");
	            		}
	            	} else if (target === "record") {
	            		if(captureState == "paused" || captureState == "waiting") {
		            		controlHTTPService.url = applianceURL + "/capture/record";
		            		debugMe("info", "Sending action " + target + " (" + controlHTTPService.url.toString() + ") to control current capture!");
		            		if(captureState == "paused") {
		            			activateInfoBox("pleasewait", resourceManager.getString("EchoMonitor","resuming_capture"));
		            		} else if(captureState == "waiting") {
		            			activateInfoBox("pleasewait", resourceManager.getString("EchoMonitor","starting_capture"));
		            		}
		            		controlHTTPService.send(dummyObject);
	            		} else {
	            			debugMe("error", "The action " + target + " can't be run in the state " + captureState + "!");
	            		}
	            	} else {
	            		debugMe("error", "The action " + target + " to control current capture is unknown!");
	            	}
            	} else {
            		debugMe("error", "Controlling of captures is not enabled (enableCaptureControl=false) in EchoMonitor configuration!");
            	}
            } // actionClick
            
            
            private function playSound(event:String):Boolean {
            	
            	return true;
            } // playSound
        ]]>
    </mx:Script>
	<mx:ApplicationControlBar dock="false" width="99%" fillAlphas="[1.0, 1.0]" fillColors="[#105761, #105761]" id="monitorControlBar" horizontalCenter="0" y="5">
		<mx:Image source="@Embed(source='assets/en_US.svg')" click="setLocale('en_US')" width="20" height="12"/>
		<mx:Image source="@Embed(source='assets/et_EE.svg')" click="setLocale('et_EE')" width="20" height="12"/>
		<!-- <mx:Image source="@Embed(source='assets/fi_FI.svg')" click="setLocale('fi_FI')" width="20" height="12"/> -->
		<mx:Image source="@Embed(source='assets/ru_RU.svg')" click="setLocale('ru_RU')" width="20" height="12"/>
		<mx:Label width="100%" textAlign="center" id="controlBarInfoLbl"/>
		<mx:Button click="startCapture('monitoring');" label="{resourceManager.getString('EchoMonitor', 'start_monitoring')}" id="startMonitoringBtn" visible="false"/>
    	<mx:Label text="{resourceManager.getString('EchoMonitor', 'select_room')}" id="chooseApplianceLbl" visible="false"/>
    	<mx:ComboBox rowCount="25" editable="false" id="applianceChooser" dataProvider="{appliances}" labelField="name" change="setMonitoredAppliance();" visible="false"></mx:ComboBox>
    	<mx:Button click="changeView();" label="{resourceManager.getString('EchoMonitor', 'exit_fullscreen')}" id="changeViewBtn"/>
    	<mx:Button click="openSettings();" label="{resourceManager.getString('EchoMonitor', 'settings')}" id="settingsBtn"/>
    	<mx:Button click="NativeApplication.nativeApplication.exit();" label="{resourceManager.getString('EchoMonitor', 'exit_application')}"/>
	</mx:ApplicationControlBar>
	<mx:TitleWindow visible="false" width="350" height="200" layout="vertical" showCloseButton="false" horizontalAlign="center" id="loginBox" horizontalCenter="0" verticalCenter="0" backgroundColor="#105761" backgroundAlpha="0.6">
			<mx:Text width="100%" textAlign="center" id="loginBoxInfoText"/>
			<mx:Grid>
				<mx:GridRow width="100%" height="100%">
					<mx:GridItem width="100%" height="100%">
						<mx:Label color="white" text="{resourceManager.getString('EchoMonitor', 'username')}:" id="loginBoxUsernameLabel"/>
					</mx:GridItem>
					<mx:GridItem width="100%" height="100%">
						<mx:TextInput id="loginBoxUsernameField"/>
					</mx:GridItem>
				</mx:GridRow>
				<mx:GridRow width="100%" height="100%">
					<mx:GridItem width="100%" height="100%">
						<mx:Label color="white" text="{resourceManager.getString('EchoMonitor', 'password')}:" id="loginBoxPasswordLabel"/>
					</mx:GridItem>
					<mx:GridItem width="100%" height="100%">
						<mx:TextInput displayAsPassword="true" id="loginBoxPasswordField"/>
					</mx:GridItem>
				</mx:GridRow>
				<mx:GridRow width="100%" height="100%">
					<mx:GridItem width="100%" height="100%">
						
					</mx:GridItem>
					<mx:GridItem width="100%" height="100%">
						<mx:CheckBox color="white" label="{resourceManager.getString('EchoMonitor', 'remember_username_and_password')}" id="loginBoxRemember"/>
					</mx:GridItem>
				</mx:GridRow>
			</mx:Grid>
			<mx:HBox width="100%" horizontalAlign="center">
				<mx:Button label="{resourceManager.getString('EchoMonitor', 'login')}" id="loginBoxLoginButton"/>
				<mx:Button label="{resourceManager.getString('EchoMonitor', 'cancel')}" id="loginBoxCancelButton"/>
			</mx:HBox>
	</mx:TitleWindow>
	<mx:VBox width="100%" height="85%" horizontalAlign="center" id="middleVBox" horizontalCenter="0" verticalCenter="0">
		<mx:Spacer height="2%"/>
	    <mx:Text id="mainInfo" fontSize="30" color="#F0DCB9" width="90%" textAlign="center" paddingBottom="-10"/>
	    <mx:Text id="secondaryInfo" fontSize="22" color="#F0DCB9" width="90%" textAlign="center"/>
	    <mx:Spacer height="2%"/>
		<mx:Canvas width="90%" id="monitorArea" visible="false" height="70%" backgroundColor="#090D0B" cornerRadius="10" borderColor="#090D0B" borderStyle="solid" showEffect="zoomIn" hideEffect="zoomOut" horizontalScrollPolicy="off" verticalScrollPolicy="off">
		    <mx:Image width="320" height="240" id="inputMonitor1" styleName="monitorImage" visible="false" horizontalCenter="-185" verticalCenter="20"/>
		    <mx:Image source="@Embed(source='assets/vu1.png')" width="14" height="240" id="audioInputLevelVUMeter" visible="false" horizontalCenter="0" verticalCenter="20" maintainAspectRatio="false"/>
		    <mx:Image source="@Embed(source='assets/vu2.png')" width="14" height="240" id="audioInputLevel" visible="false" horizontalCenter="0" maintainAspectRatio="false"/>
		    <mx:Image width="320" height="240" id="inputMonitor2" styleName="monitorImage" visible="false" horizontalCenter="185" verticalCenter="20"/>
		    <mx:Label text="" fontSize="20" textAlign="center" id="monitor1Label" visible="false" width="320" color="#F0DCB9" horizontalCenter="-185" verticalCenter="120"/>
		    <mx:Label text="" fontSize="20" textAlign="center" id="monitor2Label" visible="false" width="320" color="#F0DCB9" horizontalCenter="185" verticalCenter="120"/>
		    <mx:Label text="{resourceManager.getString('EchoMonitor', 'audio_low')}" visible="false" horizontalCenter="0" verticalCenter="-130" width="90%" color="#FF5100" fontSize="30" fontWeight="bold" textAlign="center" id="checkAudio"/>
		    <mx:Text text="" visible="false" horizontalCenter="-185" verticalCenter="20" color="#FF5100" width="320" fontSize="30" fontWeight="bold" textAlign="center" id="monitor1Error"/>
		    <mx:Text text="" visible="false" horizontalCenter="185" verticalCenter="20" color="#FF5100" width="320" fontSize="30" fontWeight="bold" textAlign="center" id="monitor2Error"/>
		    <mx:Text text="{resourceManager.getString('EchoMonitor', 'capture_is_live')}" visible="false" horizontalCenter="0" verticalCenter="160" color="#FF5100" width="90%" fontSize="20" fontWeight="bold" textAlign="center" id="captureIsLive"/>
	    </mx:Canvas>
	    <mx:Spacer height="1%"/>
	    <mx:HBox width="90%" height="16%" horizontalAlign="center" id="controlHBox" visible="false">
			<mx:Button label="{resourceManager.getString('EchoMonitor', 'stop_capture')}" id="stopButton1" color="#DDDDDD" width="200" height="50" fillColors="#ff0000"  fontSize="16" borderColor="#000000" themeColor="#000000" textRollOverColor="#FFFFFF" textSelectedColor="#FFFFFF" click="actionClick('stop');"/>
			<mx:Button label="{resourceManager.getString('EchoMonitor', 'pause_capture')}" id="pauseButton" color="#DDDDDD" width="200" height="50" fillColors="#ffff00" fontSize="16" borderColor="#000000" themeColor="#000000" textRollOverColor="#FFFFFF" textSelectedColor="#FFFFFF" click="actionClick('pause');"/>
			<mx:Button label="{resourceManager.getString('EchoMonitor', 'extend_capture')}" id="extendButton" color="#DDDDDD" width="200" height="50" fillColors="#00ff00" fontSize="16" borderColor="#000000" themeColor="#000000" textRollOverColor="#FFFFFF" textSelectedColor="#FFFFFF" click="actionClick('extend');"/>
		</mx:HBox>
	</mx:VBox>
	<mx:HBox width="90%" height="16%" horizontalAlign="center" id="resumeHBox" horizontalCenter="0" verticalAlign="middle" verticalCenter="0" visible="false">
		<mx:Button label="{resourceManager.getString('EchoMonitor', 'stop_capture')}" id="stopButton2" color="#DDDDDD" width="200" height="50" fillColors="#ff0000"  fontSize="16" borderColor="#000000" themeColor="#000000" textRollOverColor="#FFFFFF" textSelectedColor="#FFFFFF" click="actionClick('stop');"/>
		<mx:Button label="{resourceManager.getString('EchoMonitor', 'resume_capture')}" id="resumeButton" color="#DDDDDD" width="200" height="50" fillColors="#00ff00" fontSize="16" borderColor="#000000" themeColor="#000000" textRollOverColor="#FFFFFF" textSelectedColor="#FFFFFF" click="actionClick('record');"/>
	</mx:HBox>
	<mx:HBox width="90%" height="26%" horizontalAlign="center" id="adhocHBox" horizontalCenter="0" verticalAlign="middle" verticalCenter="0" visible="false">
		<mx:Button label="{resourceManager.getString('EchoMonitor', 'start_adhoc_capture')}" id="adhocButton" color="#DDDDDD" width="40%" height="100" fillColors="#00ff00" fontSize="20" borderColor="#000000" themeColor="#000000" textRollOverColor="#FFFFFF" textSelectedColor="#FFFFFF" click="startCapture('ad-hoc');"/>
	</mx:HBox>
	<mx:Canvas id="infoBox" visible="false" width="94%" height="85%" horizontalCenter="0" verticalCenter="0" backgroundColor="#000000" backgroundAlpha="0.2" cornerRadius="30" borderColor="#000000" borderStyle="solid" borderThickness="0" horizontalScrollPolicy="off" verticalScrollPolicy="off">
		<mx:Text id="infoHeader" fontSize="44" color="#FF5100" width="90%" horizontalCenter="0" verticalCenter="-40" textAlign="center" text="" fontWeight="normal"/>
		<mx:Text id="infoMessage" fontSize="22" color="#FF5100" width="90%" horizontalCenter="0" verticalCenter="40"  fontWeight="normal" text="" textAlign="center"/>
	</mx:Canvas>
	<mx:TextArea width="90%" height="20%" id="debugInfo" visible="false" backgroundColor="#105761" color="#FFFFFF" backgroundAlpha="0.5" bottom="10" horizontalCenter="0"/>
	<mx:TextArea width="80%" height="50%" id="configurationInfo" visible="false" backgroundColor="#105761" color="#FFFFFF" verticalCenter="0" horizontalCenter="0"/>
</mx:WindowedApplication>