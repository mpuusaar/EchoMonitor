<?xml version="1.0" encoding="utf-8"?>
<!--

   Copyright 2011-2013 Marko Puusaar / Estonian Information Technology Foundation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


   TODO:
    - move the user information to EncryptedLocalStore
    - handle monitoring from different timezones than the appliance with correct dates and times
    - handle locale change with more grace :)
    - [DONE] implement audio level monitoring
    - [DONE] clear audio error message when a capture ends
    - [DONE] notify the user of any network/connection problems that cause EchoMonitor not to be able to connect to the selected appliance
    - [DONE] optimize connections to the capture appliance
    - [DONE] improve the display of monitoring area (hide scrollbars)

-->
<mx:WindowedApplication
	xmlns:mx="http://www.adobe.com/2006/mxml"
	layout="absolute"
	horizontalAlign="center"
	verticalAlign="middle"
	width="900"
	height="650"
	applicationComplete="initApp(event);"
	backgroundGradientAlphas="[1.0, 1.0]"
	backgroundGradientColors="[#105761, #090D0B]"
	showStatusBar="false"
	frameRate="12">
<mx:HTTPService
	id="infoHTTPService"
	resultFormat="e4x" 
	result="infoHandler(event)"
	fault="httpFault('infoHTTPService',event)"
	requestTimeout="3" />
<mx:Zoom
	id="zoomIn"
	zoomHeightFrom="0.0"
	zoomWidthFrom="0.0"
    zoomHeightTo="1.0"
    zoomWidthTo="1.0" />
<mx:Zoom id="zoomOut" 
	zoomHeightFrom="1.0"
	zoomWidthFrom="1.0"
	zoomHeightTo="0.0"
	zoomWidthTo="0.0" />
<mx:Sequence id="doGlow" repeatCount="0">
	<mx:Glow
		duration="100"
		alphaFrom="0" alphaTo="1"
		blurXFrom="0.0" blurXTo="30.0" 
		blurYFrom="0.0" blurYTo="30.0"  strength="2"
		color="0xFF5100" />
	<mx:Glow
		duration="800"  
		alphaFrom="1" alphaTo="0"
		blurXFrom="30.0" blurXTo="0.0"
		blurYFrom="30.0" blurYTo="0.0"  strength="2"
		color="0xFF5100" />
</mx:Sequence>
<mx:GlowFilter id="okGlow"
	color="0x000000"
	alpha="1"
	blurX="20"
	blurY="20"
	quality="2" />
<mx:GlowFilter id="warningGlow"
	color="0xFF5100"
	alpha="1"
	blurX="20"
	blurY="20" />
<mx:BlurFilter id="blurredBox"
	blurX="10"
	blurY="10"
	quality="3" />
<mx:DateFormatter id="dateFormatter" 
	formatString="{resourceManager.getString('EchoMonitor', 'DATE_FORMAT')}" />
<mx:DateFormatter id="timeFormatter"
	formatString="{resourceManager.getString('EchoMonitor', 'TIME_FORMAT')}" />
<mx:DateFormatter id="timeWithSecondsFormatter"
	formatString="{resourceManager.getString('EchoMonitor', 'TIME_WITH_SECONDS_FORMAT')}" />
<mx:Metadata>
  [ResourceBundle("EchoMonitor")]
</mx:Metadata>
<mx:Script>
        <![CDATA[
        	import mx.events.FlexEvent;
            import flash.display.Loader;
		    import flash.events.TimerEvent;
		    import flash.utils.Timer;
		    import mx.collections.*;
			import mx.controls.Alert;
			import mx.events.AIREvent;
            import mx.rpc.http.HTTPService;
            import mx.rpc.events.ResultEvent;
            import mx.rpc.events.FaultEvent;
            import mx.utils.Base64Encoder;
            import mx.utils.StringUtil;
            
            // Application variables
            private var applianceURL:String;
            private var KeysDown:Object = new Object();
            private var username:String, password:String;
            private var monitorTimer:Timer, infoTimer:Timer;
            private var audioError:int, videoError:int, displayError:int;
            private var audioErrorStartTime:Date;
            private var audioErrorCount:int = 0;
            private var monitorImageLoader:Array = [];
            private var monitorImageRequestHeader:URLRequestHeader;
            private var controlBarInfoErrorColor:String = "#C80101";
            private var configurationFileName:String = "configuration.xml";
            private var networkErrorCount:int = 0;
            // End of application variables

			// Configuration variables and their default values
			private var audioErrorLevel:int = 5000;
			private var audioErrorLimit:int = 20;
			private var audioWarningLimit:int = 10;
			private var configuration:Object = new Object();
            private var infoTimerActive:int = 3000;
            private var infoTimerIdle:int = 10000;
            // End on configuration variables

            private const day:int = 1000 * 60 * 60 * 24;
            private const hour:int = 1000 * 60 * 60;
            private const minute:int = 1000 * 60;

            private const monitorImageWidth:int = 320;

            private var configurationFile:File;
            private var configurationFileStream:FileStream;
            private var configurationXML:XML;
            [Bindable] private var appliances:XMLListCollection;

            // initApp
            public function initApp(e:Event):void {
				resourceManager.addEventListener(Event.CHANGE, applyLocale);
				
				// Set default values for configuration
				configuration.audioErrorLevel = 5000;
				configuration.audioErrorLimit = 20;
				configuration.audioWarningLimit = 10;
				configuration.debug = false;
				configuration.defaultLocale = "en_US";
				configuration.hideLiveStreamInfo = false;
				configuration.hideSourceLabel = false;
				configuration.hideVUMeter = false;
				configuration.infoTimerActive = 3000;
				configuration.infoTimerIdle = 10000;
				configuration.showFirstApplianceAutomatically = false;
				configuration.showRoomSelection = true;
				configuration.startFullscreen = true;

				// Load the configuration values from configuration file
            	loadConfiguration();
            	
            	if(configuration.defaultLocale) {
            		setLocale(configuration.defaultLocale);
            	}

				if(configuration.startFullscreen) {
	            	stage.displayState = flash.display.StageDisplayState.FULL_SCREEN_INTERACTIVE;
	   			}

            	if(configuration.showRoomSelection) {
            		chooseApplianceLbl.setVisible(true);
            		applianceChooser.setVisible(true);
            	}

            	if(configuration.debug) {
            		debugInfo.setVisible(true);
            	}
            	
            	stage.addEventListener(KeyboardEvent.KEY_DOWN, reportKeyDown);
            	stage.addEventListener(KeyboardEvent.KEY_UP, reportKeyUp);
				
				monitorArea.filters = [okGlow];
				errorHeader.filters = [okGlow];
				errorMessage.filters = [okGlow];
				
				this.addEventListener(AIREvent.APPLICATION_ACTIVATE, applicationActivate);
				this.addEventListener(AIREvent.APPLICATION_DEACTIVATE, applicationDeactivate);

				infoTimer = new Timer(infoTimerIdle, 0);
		        infoTimer.addEventListener("timer", infoTimerHandler);

				monitorImageLoader[0] = new Loader(); // Just in case :) Theoretically this should never be used
				monitorImageLoader[1] = new Loader(); // For loading the first monitoring image
				monitorImageLoader[2] = new Loader(); // For loading the second monitoring image

				if(configuration.showFirstApplianceAutomatically) { // Check if hte first appliance in the appliances list should be showed automatically
					setMonitoredAppliance();
		    	}
            } // initApp
            
            
            // loadConfiguration
            private function loadConfiguration():void {
            	configurationFile = File.applicationStorageDirectory.resolvePath(configurationFileName);
            	debugMe("info", "Configuration: " + configurationFile.nativePath);
            	if(configurationFile.exists) { // Does the configuraton file exist?
					configurationFileStream = new FileStream();
				    configurationFileStream.open(configurationFile, FileMode.READ);
				    configurationXML = XML(configurationFileStream.readUTFBytes(configurationFileStream.bytesAvailable));
					configurationFileStream.close();
					
					if(configurationXML.appliances.children().length() > 0) {
						appliances = new XMLListCollection(configurationXML.appliances.appliance);
					} else {
						Alert.show(StringUtil.substitute(resourceManager.getString("EchoMonitor","error_no_appliances_in_configuration"), configurationFile.nativePath.toString()),resourceManager.getString("EchoMonitor","error_title"),Alert.OK,this,function(e:Event):void {
            				NativeApplication.nativeApplication.exit();
            			});	
					}
					
					audioErrorLevel = int(configurationXML.audioErrorLevel);
					audioErrorLimit = int(configurationXML.audioErrorLimit);
					audioWarningLimit = int(configurationXML.audioWarningLimit);
					if(configurationXML.debug != undefined) {
						configuration.debug = configurationXML.debug.toLowerCase() == "true";
					}
					if(configurationXML.defaultLocale != undefined) {
						configuration.defaultLocale = String(configurationXML.defaultLocale);
					}
					if(configurationXML.hideLiveStreamInfo != undefined) {
						configuration.hideLiveStreamInfo = configurationXML.hideLiveStreamInfo.toLowerCase() == "true";
					}
					if(configurationXML.hideSourceLabel != undefined) {
						configuration.hideSourceLabel = configurationXML.hideSourceLabel.toLowerCase() == "true";
					}
					if(configurationXML.hideVUMeter != undefined) {
						configuration.hideVUMeter = configurationXML.hideVUMeter.toLowerCase() == "true";
					}
					infoTimerActive = int(configurationXML.infoTimerActive);
					infoTimerIdle = int(configurationXML.infoTimerIdle);
					if(configurationXML.showFirstApplianceAutomatically != undefined) {
						configuration.showFirstApplianceAutomatically = configurationXML.showFirstApplianceAutomatically.toLowerCase() == "true";
					}
					if(configurationXML.showRoomSelection != undefined) {
						configuration.showRoomSelection = configurationXML.showRoomSelection.toLowerCase() == "true";
					}
					if(configurationXML.startFullscreen != undefined) {
						configuration.startFullscreen = configurationXML.startFullscreen.toLowerCase() == "true";
					}
					
					debugMe("info", configurationXML.toString());
            	} else { // The configuration file does not exist
					setUpConfigurationFile(); // Set up the configuration file
            	}
            } // private function loadConfiguration():void {

            
            // setUpConfigurationFile
            private function setUpConfigurationFile():void {
            	if(!configurationFile.exists)
            	{
            		if(File.applicationDirectory.resolvePath(configurationFileName).exists) {
            			File.applicationDirectory.resolvePath(configurationFileName).copyTo(configurationFile)
						Alert.show(StringUtil.substitute(resourceManager.getString("EchoMonitor","error_configuration_file_missing"), configurationFile.nativePath.toString()),resourceManager.getString("EchoMonitor","error_title"),Alert.OK,this,function(e:Event):void {
        					NativeApplication.nativeApplication.exit();
        				});
            		} else if(File.applicationDirectory.resolvePath("default_" + configurationFileName).exists) {
            			File.applicationDirectory.resolvePath("default_" + configurationFileName).copyTo(configurationFile)
						Alert.show(StringUtil.substitute(resourceManager.getString("EchoMonitor","error_configuration_file_missing"), configurationFile.nativePath.toString()),resourceManager.getString("EchoMonitor","error_title"),Alert.OK,this,function(e:Event):void {
        					NativeApplication.nativeApplication.exit();
        				});
            		} // if(File.applicationDirectory.resolvePath(configurationFileName).exists)
            	} else {
            		// TODO
            		// What if the configuration file exists?
            	} // if(!configurationFile.exists)
            } // private function setUpConfigurationFile():void {

            
            // infoTimerHandler
            private function infoTimerHandler(event:TimerEvent):void {
            	infoHTTPService.send();
            } // private function infoTimerHandler(event:TimerEvent):void {


            // infoHandler
            private function infoHandler(event:ResultEvent):void {
                var result:XML = event.result as XML;
                var now:Date = new Date();
                var startTime:Date;
                var durationInMinutes:int;
                var difference:Number;
                var minutesToNextCapture:int;
                var hoursToNextCapture:int;
                
                deactivateErrorBox();
            	networkErrorCount = 0;
                
				debugMe("info","Result XML from infoHandler:\n" + result);
                
                if(result.current.schedule.parameters != undefined) {
                	startTime = isoToDate(result.current.schedule.child("start-time"));
                	durationInMinutes = int(result.current.duration)/60;
	               	var captureEnd:Number = startTime.getTime()+(result.current.duration*1000);
	                var secondsToCaptureEnd:Number = Math.round((captureEnd-now.getTime())/1000);
	                	
                	if(result.current.state == "active") {
                		infoTimer.delay = infoTimerActive;
                		
	                	activateMonitoring(result);
	                	
	                	if(secondsToCaptureEnd >= 59)
	                	{
	                		// infoTimer.delay = infoTimerIdle;
		                	mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","active_capture_for_more_than_1_minute"), Math.round(secondsToCaptureEnd/60).toString());
		                } else if(secondsToCaptureEnd > 0) {
		                	// infoTimer.delay = infoTimerActive;
		                	mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","active_capture_ending_in_less_than_1_minute"), secondsToCaptureEnd.toString());
		                } else if(secondsToCaptureEnd <= 0) {
		                	mainInfo.text = resourceManager.getString("EchoMonitor","capture_is_stopping");
		                }
	                	secondaryInfo.text = "\"" + result.current.schedule.parameters.title + "\"";
                	} else if(result.current.state == "paused") {
	                	deactivateMonitoring();
	                	mainInfo.text = resourceManager.getString("EchoMonitor","active_capture_has_been_paused");
	                	secondaryInfo.text = "\"" + result.current.schedule.parameters.title + "\"";
	                } else if(result.current.schedule.parameters != undefined && result.current.state == "waiting") {
	                	deactivateMonitoring();
	                	infoTimer.delay = infoTimerActive;
	                	difference = startTime.getTime()-now.getTime();
	        	        var secondsToNextCapture:int = Math.round(difference/1000);
	        	        minutesToNextCapture = Math.round(difference/minute);
	                	if(secondsToNextCapture > 90) {
							mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_less_than_1_hour"), minutesToNextCapture.toString());
            	    	} else if(secondsToNextCapture > 60) {
							mainInfo.text = resourceManager.getString("EchoMonitor","next_capture_in_about_1_minute");
            	    	} else if(secondsToNextCapture > 0) {
            	    		mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_seconds"), secondsToNextCapture.toString());
            	    	} else if(secondsToNextCapture <= 0) {
            	    		mainInfo.text = resourceManager.getString("EchoMonitor","capture_is_starting");
            	    	}
	                	secondaryInfo.text = "\"" + result.current.schedule.parameters.title + "\"\n" + dateFormatter.format(startTime) + " @ " + timeFormatter.format(startTime) + " / " + durationInMinutes + " " + resourceManager.getString("EchoMonitor","minutes");
	                }
                } else if(result.next.parameters != undefined) {
                	deactivateMonitoring();
                	infoTimer.delay = infoTimerIdle;
	                startTime = isoToDate(result.next.child("start-time"));
        	        difference = startTime.getTime()-now.getTime();
        	        minutesToNextCapture = Math.round(difference/minute);
        	        hoursToNextCapture = Math.round(difference/hour);
					var daysToNextCapture:int = Math.round(difference/day);
					var a:int, b:int;
					durationInMinutes = int(result.next.child("duration"))/60;

            	    if(difference/day < 1) {
            	    	if(minutesToNextCapture >= 60) {
            	    		a = Math.floor(minutesToNextCapture / 60);
            	    		b = minutesToNextCapture - (a*60);
            	    		mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_more_than_1_hour"), a.toString(), b.toString());
            	    	} else if(minutesToNextCapture > 1) {
							mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_less_than_1_hour"), minutesToNextCapture.toString());
            	    	} else if(minutesToNextCapture == 1) {
							mainInfo.text = resourceManager.getString("EchoMonitor","next_capture_in_about_1_minute");
            	    	} else if(minutesToNextCapture < 1) {
            	    		mainInfo.text = resourceManager.getString("EchoMonitor","next_capture_in_less_than_1_minute");
            	    	}
	                } else {
	                	a = Math.floor(hoursToNextCapture / 24);
	                	b = hoursToNextCapture - (a * 24);
						mainInfo.text = StringUtil.substitute(resourceManager.getString("EchoMonitor","next_capture_in_days"), a.toString(), b.toString());
        	        }
        	        
        	        secondaryInfo.text = "\"" + result.next.parameters.title + "\"\n" + dateFormatter.format(startTime) + " @ " + timeFormatter.format(startTime) + " / " + durationInMinutes + " " + resourceManager.getString("EchoMonitor","minutes");;
        	    } else {
        	    	deactivateMonitoring();
        	    	infoTimer.delay = infoTimerIdle;
        	    	mainInfo.text = resourceManager.getString("EchoMonitor", "no_next_capture");
        	    	secondaryInfo.text = "";
        	    }
            } // private function infoHandler(event:ResultEvent):void {


            // monitorHandler
            private function monitorHandler(result:XML):void {
            	if(result.current.state == "active" || result.current.child("confidence-monitoring") == "true" ) {
            		if(!monitorArea.visible) {
	            		monitorArea.setVisible(true);
            		}
            		
            		var warning:Boolean = false;
            		var error:Boolean = false;
                	var randString:String = new Date().getTime().toString();
                	
                	var audioResult:XMLList = result.current.sources.source.(child("class").toString().search("audio")>-1);
                	var audioPeakLevel:int = audioResult.channels.channel[1].peak;

                	if(audioResult.child("signal-present") == "false" || audioPeakLevel <= audioErrorLevel) { // Audio signal missing
                		audioErrorCount++;
                		if(audioErrorCount > audioWarningLimit) {
                			if(audioErrorCount > audioErrorLimit) {
                				error = true;
                			} else {
                				warning = true;
                			}
	                		if(!checkAudio.visible) {
	                			checkAudio.setVisible(true);
	                		}
	                	}
                	} else { // Audio signal present
                		audioErrorCount = 0;
                		if(checkAudio.visible) {
                			checkAudio.setVisible(false);
                		}
                	}
                	
                	// Set audio level meter (VU Meter)
                	if(!configuration.hideVUMeter) { // Should the audio VU meter be shown
	                	audioInputLevel.y = audioInputLevelVUMeter.y - (audioPeakLevel * (240 / 32768)); // Set the VU meter by moving the partly transparent rectangle on the VU meter image
                		audioInputLevel.setVisible(true);
	                	audioInputLevelVUMeter.setVisible(true);
	                } else { // or should the audio VU meter be hidden
	                	audioInputLevel.setVisible(false);
	                	audioInputLevelVUMeter.setVisible(false);
	                }

					var sources:XMLList = result.current.sources.source;
					var monitorUsed:Number = 1;
					var inputMonitor:Object;
					var monitorLabel:Object;
					var monitorError:Object;
					var monitorImageName:String;
                	for(var i:Number = 0; i < 3; i++) {
                		inputMonitor = this["inputMonitor" + monitorUsed];
            			monitorLabel = this["monitor" + monitorUsed + "Label"];
            			monitorError = this["monitor" + monitorUsed + "Error"];
                		if(sources[i] && (sources[i].child("class") == "video" || sources[i].child("class") == "vga")) {
                			if(sources[i].child("signal-present") == "true") {
                				if(monitorError.visible) { // Check if the source error message is visible
	                				monitorError.setVisible(false); // Hide source error message
	                			}
	                			
	                			if(sources[i].child("class") == "video") {
	                				monitorLabel.text = resourceManager.getString('EchoMonitor', 'video');
	                			} else {
	                				monitorLabel.text = resourceManager.getString('EchoMonitor', 'display');
	                			}
	                			
	                			if(configuration.hideSourceLabel) { // Check if the source label should be hidden
		                			monitorLabel.setVisible(false); // Hide the source label
		                		} else {
		                			monitorLabel.setVisible(true); // Show the source label
		                		}
		                		
			                	monitorImageName = sources[i].child("thumbnail"); // Get the thumbnail image name
			                	if(monitorImageName.length == 0) { // Check if the thumbnail image name has not been set
			                		monitorImageName = "video_pal_4.jpg"; // Set the thumbnail image name to video_pal_4.jpg
			                	}
			                	getMonitorImage(monitorUsed, applianceURL + "/monitoring/" + monitorImageName + "?" + randString, inputMonitor);
                			} else {
                				error = true;
	                			monitorLabel.setVisible(false); // Hide the source label
	                			inputMonitor.setVisible(false);
	                			if(sources[i].child("class") == "video") {
	                				monitorError.text = resourceManager.getString('EchoMonitor', 'video_missing');
	                			} else {
	                				monitorError.text = resourceManager.getString('EchoMonitor', 'display_missing');
	                			}
	                			if(!monitorError.visible) {
	                				monitorError.setVisible(true);
	                			}
                			}
                			
                			monitorUsed++;
                		} else if (sources[i] && sources[i].child("class") != "audio") {
                			if(monitorLabel) {
                				monitorLabel.setVisible(false); // Hide the source label
                			}
                			if(monitorError) {
                				monitorError.setVisible(false); // Hide the error message
                			}
                			if(inputMonitor) {
                				inputMonitor.setVisible(false);
                			}
                		}
                		
                		// Check if the current capture is LIVE and notify the user about it
                		var outputType:String = result.current.child("output-type").toString();
                		if(!configuration.hideLiveStreamInfo && outputType.indexOf("live") >= 0) { // Is the current capture LIVE?
                			// Capture is LIVE
                			if(!captureIsLive.visible) { // Is the LIVE text visible? 
                				captureIsLive.setVisible(true); // Set the LIVE text visible
                			}
                		} else {
                			// Capture is not LIVE
                			if(captureIsLive.visible) {
                				captureIsLive.setVisible(false); // Hide the LIVE text
                			}
                		}
                	}

					/*                	
					var capturedSources:String = String(result.current.schedule.parameters.child("name-key"));
            		if(capturedSources.length == 0) {
            			capturedSources = "audio-display-video";
            		}
            		
                	if(capturedSources.search("video") >= 0) {
	                	var videoResult:XMLList = result.current.sources.source.(child("class").toString().search("video")>-1);
	                	if(videoResult.child("signal-present") == "true") { // Video signal present
	                		if(monitor1Error.visible) {
	                			monitor1Error.setVisible(false);
	                		}
		                	monitor1Label.setVisible(true);
		                	monitorImageName = videoResult.child("thumbnail");
		                	if(monitorImageName.length == 0) {
		                		monitorImageName = "video_pal_4.jpg";
		                	}
		                	getMonitorImage("video", applianceURL + "/monitoring/" + monitorImageName + "?" + randString, inputMonitor1);
	                	} else { // Video signal missing
	                		error = true;
	                		mon1Label.setVisible(false);
	                		inputMonitor1.setVisible(false);
	                		if(!mon1Error.visible) {
	                			mon1Error.setVisible(true);
	                		}
	                	}
	                } else {
	                	mon1Label.setVisible(false);
	                	inputMonitor1.setVisible(false);
	                	mon1Error.setVisible(false);
	                }
                	
                	if(capturedSources.search("display") >= 0) {
	                	var displayResult:XMLList = result.current.sources.source.(child("class").toString().search("vga")>-1);
	                	if(displayResult.child("signal-present") == "true") { // Display signal present
	                		if(mon2Error.visible) {
	                			mon2Error.setVisible(false);
	                		}
		                	mon2Label.setVisible(true);
		                	monitorImageName = displayResult.child("thumbnail");
		                	if(monitorImageName.length == 0) {
		                		monitorImageName = "vga_display_1.jpg";
		                	}
		                	getMonitorImage("display", applianceURL + "/monitoring/" + monitorImageName + "?" + randString, inputMonitor2);
		                } else { // Display signal missing
		                	error = true;
		                	mon2Label.setVisible(false);
		                	inputMonitor2.setVisible(false);
		                	if(!mon2Error.visible) {
		                		mon2Error.setVisible(true);
		                	}
		                }
                	} else {
                		mon2Label.setVisible(false);
                		inputMonitor2.setVisible(false);
                		mon2Error.setVisible(false);
                	}
					*/

					if(!warning && !error) {
						if(doGlow.isPlaying) {
							doGlow.stop();
						}
						monitorArea.filters = [okGlow];
					} else if(error) {
						if(!doGlow.isPlaying) {
							doGlow.play([monitorArea]);
						}
					} else {
						monitorArea.filters = [warningGlow];
					}
                } else {
                	if(monitorArea.visible) {
                		monitorArea.setVisible(false);
                	}

                	monitor1Label.setVisible(false);
                	inputMonitor1.setVisible(false);
                	monitor2Label.setVisible(false);
                	inputMonitor2.setVisible(false);
                }
            } // monitorHandler


            // httpFault
            private function httpFault(source:String, event:FaultEvent):void {
            	if(event.fault.faultCode == "Server.Error.Request") {
            		networkErrorCount++;
            	}
            	
            	if(networkErrorCount > 3) {
            		activateErrorBox("httpFault");
            	}
            	
                debugMe("error", "httpFault: (" + source + ") " + event.fault.faultString + " [" + event.fault.faultCode + "]");
            } // httpFault


            private function activateErrorBox(type:String):void {
            	if(type == "httpFault") {
					errorHeader.text = resourceManager.getString('EchoMonitor', 'connection_error_header');
					errorMessage.text = resourceManager.getString('EchoMonitor', 'connection_error_message');
					middleVBox.filters = [blurredBox];
					errorBox.setVisible(true);
            	}
            } //activateErrorBox


            private function deactivateErrorBox():void {
            	middleVBox.filters = null;
            	errorBox.setVisible(false);
            } //deactivateErrorBox


            // getMonitorImage
			private function getMonitorImage(inputMonitorImageNum:Number, address:String, toImage:Object):void {
	            var request:URLRequest = new URLRequest(encodeURI(address));
	            request.method = URLRequestMethod.POST; // Set the methof (POST) for the upcoming request
	            request.requestHeaders.push(monitorImageRequestHeader); // Set the authentication header for the upcoming request
				var _loader:Loader; // Initiate new loader
        		monitorImageLoader[inputMonitorImageNum].unload(); // Clear previous loading information
        		_loader = monitorImageLoader[inputMonitorImageNum];
        		if(!_loader.contentLoaderInfo.hasEventListener(Event.COMPLETE)) {
					_loader.contentLoaderInfo.addEventListener(Event.COMPLETE,function(e:Event):void{ 
						toImage.source = e.currentTarget.content;
						if(!toImage.visible) {
							toImage.setVisible(true);
						}
						var imageWidth:int = e.currentTarget.width;
						var imageHeight:int = e.currentTarget.height;
						var imageAspectRatio:Number = imageWidth / imageHeight;
						var newImageHeight:int = (imageHeight >= 240) ? 240 : imageHeight;
						var newImageWidth:int = (imageHeight >= 240) ? 240 * imageAspectRatio : imageWidth;
						if(toImage.width != newImageWidth || toImage.height != newImageHeight) {
							toImage.width = newImageWidth;
							toImage.height = newImageHeight;
							if(toImage.id == "inputMonitor1") {
								//inputMonitor1_hc = -185;
							} else {
								//inputMonitor2_hc = 185;
							}
							//toImage.verticalCenter = 20;
						}
					});
        		}
				_loader.load(request);
			} // getMonitorImage


			// applyLocale
			private function applyLocale(e:Event):void {
	        //    dateValue = dateFormatter.format(d);
	        //    timeValue = timeFormatter.format(d);
	        //    currencyValue = currencyFormatter.format(1000);
	        } // applyLocale


			// getTimestamp
            private function getTimestamp(date:Date):Number {
				var unixTime:Number = Math.round(date.getTime()/1000);
				return unixTime;
			} // getTimestamp


            // isoToDate
            private function isoToDate(value:String):Date {
                var dateStr:String = value;
                dateStr = dateStr.replace(/\-/g, "/");
                dateStr = dateStr.replace("T", " ");
                dateStr = dateStr.replace("Z", " GMT-0000");
                dateStr = dateStr.replace(".000", "");
                return new Date(Date.parse(dateStr));
            } // isoToDate


            // getBase64UsernamePassword
            private function getBase64UsernamePassword():String {
            	var encoder:Base64Encoder = new Base64Encoder();
        		encoder.insertNewLines = false;
				encoder.encode(username + ":" + password);
				return encoder.toString();
            } // getBase64UsernamePassword


            // setMonitoredAppliance
            private function setMonitoredAppliance():void {
            	applianceURL = applianceChooser.selectedItem.address;
            	username = applianceChooser.selectedItem.username;
            	password = applianceChooser.selectedItem.password;
            	var base64UsernamePassword:String = getBase64UsernamePassword();
            	
            	infoHTTPService.url = applianceURL + "/status/captures";
				infoHTTPService.headers = {Authorization:"Basic " + base64UsernamePassword};
            	infoHTTPService.send();
            	if(!infoTimer.running) {
            		infoTimer.start();
            	}

	            monitorImageRequestHeader = new URLRequestHeader("Authorization","Basic " + base64UsernamePassword);
            	
            	debugMe("info", "Appliance selected: " + applianceChooser.selectedItem.name + " (" + applianceURL + ")");
			} // setMonitoredAppliance


			// activateMonitoring
			private function activateMonitoring(result:XML):void {
				monitorHandler(result);
			} // activateMonitoring


			// deactivateMonitoring
			private function deactivateMonitoring():void {
				if(monitorArea.visible) {
					monitorArea.setVisible(false);
				}
				if(doGlow.isPlaying) {
					doGlow.stop();
				}
				
				monitorArea.filters = [okGlow];
				audioErrorCount = 0;
        		if(checkAudio.visible) {
        			checkAudio.setVisible(false);
        		}
        		if(monitor1Label.visible) {
        			monitor1Label.setVisible(false);
        		}
        		if(monitor1Error.visible) {
        			monitor1Error.setVisible(false);
        		}
        		if(inputMonitor1.visible) {
        			inputMonitor1.setVisible(false);
        		}
        		if(monitor2Label.visible) {
        			monitor2Label.setVisible(false);
        		}
        		if(monitor2Error.visible) {
        			monitor2Error.setVisible(false);
        		}
        		if(inputMonitor2.visible) {
        			inputMonitor2.setVisible(false);
        		}
			} // deactivateMonitoring


			// changeView
			private function changeView():void {
				if(stage.displayState != StageDisplayState.NORMAL) {
					stage.displayState = StageDisplayState.NORMAL;
					changeViewBtn.label = resourceManager.getString("EchoMonitor", "fullscreen");
				} else {
					stage.displayState = StageDisplayState.FULL_SCREEN_INTERACTIVE;
					changeViewBtn.label = resourceManager.getString("EchoMonitor", "exit_fullscreen");
				}
			} // changeView


			// setLocale
			private function setLocale(locale:String):void {
				resourceManager.localeChain = [locale];
			} // setLocale


			// debugMe
			private function debugMe(type:String, debugString:String):void {
				if(configuration.debug && debugString.length > 0) {
					var now:Date = new Date();
					debugInfo.text += dateFormatter.format(now) + " " + timeWithSecondsFormatter.format(now) + ":\n" + debugString + "\n ----- \n";
				}
			} // debugMe


			// applicationActivate
			private function applicationActivate(event:Event):void {
			    stage.frameRate = 12;
			} // applicationActivate


			// applicationDeactivate
			private function applicationDeactivate(event:Event):void {
			    stage.frameRate = 1;
			} // applicationDeactivate


			// reportKeyDown
			private function reportKeyDown(e:KeyboardEvent):void {
            	switch(e.keyCode) {
            		case Keyboard.A:
            			KeysDown.A = true;
            			break;
            		case Keyboard.CONTROL:
            			KeysDown.CONTROL = true;
            			break;
            		case Keyboard.D:
            			KeysDown.D = true;
            			break;
            		case Keyboard.F:
            			KeysDown.F = true;
            			break;
					case Keyboard.H:
            			KeysDown.H = true;
            			break;
            		case Keyboard.L:
            			KeysDown.L = true;
            			break;
            	}
            	checkKeys();
            } // reportKeyDown


            // reportKeyUp
            private function reportKeyUp(e:KeyboardEvent):void {
            	switch(e.keyCode) {
            		case Keyboard.A:
            			KeysDown.A = false;
            			break;
            		case Keyboard.CONTROL:
            			KeysDown.CONTROL = false;
            			break;
            		case Keyboard.D:
            			KeysDown.D = false;
            			break;
            		case Keyboard.F:
            			KeysDown.F = false;
            			break;
					case Keyboard.H:
            			KeysDown.H = false;
            			break;
            		case Keyboard.L:
            			KeysDown.L = false;
            			break;
            	}
				checkKeys();
            } // reportKeyUp


            // checkKeys
            private function checkKeys():void {
            	if(KeysDown.CONTROL && KeysDown.H) { // Hides or shows the top control bar if CTRL+H is pressed on the keyboard
            		monitorControlBar.visible = !monitorControlBar.visible;
            	} else if(KeysDown.CONTROL && KeysDown.A) {
            		configuration.hideVUMeter = !configuration.hideVUMeter;
            	} else if(KeysDown.CONTROL && KeysDown.D) { // Hides or shows the debugging area if CTRL+D is pressed on the keyboard
            		configuration.debug = !configuration.debug;
            		debugInfo.visible = !debugInfo.visible;
            	} else if(KeysDown.CONTROL && KeysDown.F) {
            		changeView();
            	} else if(KeysDown.CONTROL && KeysDown.L) {
            		configuration.hideSourceLabel = !configuration.hideSourceLabel;
            	}
            } // checkKeys
        ]]>
    </mx:Script>
	<mx:ApplicationControlBar dock="true" id="monitorControlBar" y="0" x="0">
		<mx:Image source="@Embed(source='assets/en_US.svg')" click="setLocale('en_US')" width="20" height="12"/>
		<mx:Image source="@Embed(source='assets/et_EE.svg')" click="setLocale('et_EE')" width="20" height="12"/>
		<mx:Spacer width="100%"/>
		<mx:Label width="100%" textAlign="center" id="controlBarInfoLbl"/>
		<mx:Spacer width="100%"/>
    	<mx:Label text="{resourceManager.getString('EchoMonitor', 'select_room')}" id="chooseApplianceLbl" visible="false"/>
    	<mx:ComboBox editable="false" id="applianceChooser" dataProvider="{appliances}" labelField="name" change="setMonitoredAppliance();" visible="false"></mx:ComboBox>
    	<mx:Button click="changeView();" label="{resourceManager.getString('EchoMonitor', 'exit_fullscreen')}" id="changeViewBtn"/>
    	<mx:Button click="NativeApplication.nativeApplication.exit();" label="{resourceManager.getString('EchoMonitor', 'exit_application')}"/>
	</mx:ApplicationControlBar>
	<mx:TitleWindow visible="false" width="350" height="200" layout="vertical" showCloseButton="false" horizontalAlign="center" id="loginBox" horizontalCenter="0" verticalCenter="0" backgroundColor="#105761" backgroundAlpha="0.6">
			<mx:Text width="100%" textAlign="center" id="loginBoxInfoText"/>
			<mx:Grid>
				<mx:GridRow width="100%" height="100%">
					<mx:GridItem width="100%" height="100%">
						<mx:Label color="white" text="{resourceManager.getString('EchoMonitor', 'username')}:" id="loginBoxUsernameLabel"/>
					</mx:GridItem>
					<mx:GridItem width="100%" height="100%">
						<mx:TextInput id="loginBoxUsernameField"/>
					</mx:GridItem>
				</mx:GridRow>
				<mx:GridRow width="100%" height="100%">
					<mx:GridItem width="100%" height="100%">
						<mx:Label color="white" text="{resourceManager.getString('EchoMonitor', 'password')}:" id="loginBoxPasswordLabel"/>
					</mx:GridItem>
					<mx:GridItem width="100%" height="100%">
						<mx:TextInput displayAsPassword="true" id="loginBoxPasswordField"/>
					</mx:GridItem>
				</mx:GridRow>
				<mx:GridRow width="100%" height="100%">
					<mx:GridItem width="100%" height="100%">
						
					</mx:GridItem>
					<mx:GridItem width="100%" height="100%">
						<mx:CheckBox color="white" label="{resourceManager.getString('EchoMonitor', 'remember_username_and_password')}" id="loginBoxRemember"/>
					</mx:GridItem>
				</mx:GridRow>
			</mx:Grid>
			<mx:HBox width="100%" horizontalAlign="center">
				<mx:Button label="{resourceManager.getString('EchoMonitor', 'login')}" id="loginBoxLoginButton"/>
				<mx:Button label="{resourceManager.getString('EchoMonitor', 'cancel')}" id="loginBoxCancelButton"/>
			</mx:HBox>
	</mx:TitleWindow>
	<mx:VBox width="100%" height="85%" horizontalAlign="center" id="middleVBox" horizontalCenter="0" verticalCenter="0">
		<mx:Spacer height="2%"/>
	    <mx:Text id="mainInfo" fontSize="30" color="#F0DCB9" width="90%" textAlign="center" paddingBottom="-10"/>
	    <mx:Text id="secondaryInfo" fontSize="22" color="#F0DCB9" width="90%" textAlign="center"/>
	    <mx:Spacer height="2%"/>
		<mx:Canvas width="90%" id="monitorArea" visible="false" height="70%" backgroundColor="#090D0B" cornerRadius="10" borderColor="#090D0B" borderStyle="solid" showEffect="zoomIn" hideEffect="zoomOut" horizontalScrollPolicy="off" verticalScrollPolicy="off">
		    <mx:Image width="320" height="240" id="inputMonitor1" styleName="monitorImage" visible="false" horizontalCenter="-185" verticalCenter="20"/>
		    <mx:Image source="@Embed(source='assets/vu1.png')" width="14" height="240" id="audioInputLevelVUMeter" visible="false" horizontalCenter="0" verticalCenter="20" maintainAspectRatio="false"/>
		    <mx:Image source="@Embed(source='assets/vu2.png')" width="14" height="240" id="audioInputLevel" visible="false" horizontalCenter="0" maintainAspectRatio="false"/>
		    <mx:Image width="320" height="240" id="inputMonitor2" styleName="monitorImage" visible="false" horizontalCenter="185" verticalCenter="20"/>
		    <mx:Label text="" fontSize="20" textAlign="center" id="monitor1Label" visible="false" width="320" color="#F0DCB9" horizontalCenter="-185" verticalCenter="120"/>
		    <mx:Label text="" fontSize="20" textAlign="center" id="monitor2Label" visible="false" width="320" color="#F0DCB9" horizontalCenter="185" verticalCenter="120"/>
		    <mx:Label text="{resourceManager.getString('EchoMonitor', 'audio_low')}" visible="false" horizontalCenter="0" verticalCenter="-130" width="90%" color="#FF5100" fontSize="30" fontWeight="bold" textAlign="center" id="checkAudio"/>
		    <mx:Text text="" visible="false" horizontalCenter="-185" verticalCenter="20" color="#FF5100" width="320" fontSize="30" fontWeight="bold" textAlign="center" id="monitor1Error"/>
		    <mx:Text text="" visible="false" horizontalCenter="185" verticalCenter="20" color="#FF5100" width="320" fontSize="30" fontWeight="bold" textAlign="center" id="monitor2Error"/>
		    <mx:Text text="{resourceManager.getString('EchoMonitor', 'capture_is_live')}" visible="false" horizontalCenter="0" verticalCenter="160" color="#FF5100" width="90%" fontSize="20" fontWeight="bold" textAlign="center" id="captureIsLive"/>
	    </mx:Canvas>
	</mx:VBox>
	<mx:Canvas id="errorBox" visible="false" width="94%" height="85%" horizontalCenter="0" verticalCenter="0" backgroundColor="#000000" backgroundAlpha="0.2" cornerRadius="30" borderColor="#000000" borderStyle="solid" borderThickness="0" horizontalScrollPolicy="off" verticalScrollPolicy="off">
		<mx:Text id="errorHeader" fontSize="44" color="#FF5100" width="90%" horizontalCenter="0" verticalCenter="-40" textAlign="center" text="Network Error!" fontWeight="normal"/>
		<mx:Text id="errorMessage" fontSize="22" color="#FF5100" width="90%" horizontalCenter="0" verticalCenter="40"  fontWeight="normal" text="" textAlign="center"/>
	</mx:Canvas>
	<mx:TextArea width="90%" height="20%" id="debugInfo" visible="false" backgroundColor="#105761" color="#FFFFFF" backgroundAlpha="0.5" bottom="10" horizontalCenter="0"/>
</mx:WindowedApplication>